// Code generated by cmd/cgo; DO NOT EDIT.

//line /Volumes/2T/compile/lede/dl/go-mod-cache/github.com/coreos/go-systemd@v0.0.0-20191104093116-d3cd4ed1dbcf/util/util_cgo.go:1:1
// Copyright 2016 CoreOS, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// +build cgo

package util

// #include <stdlib.h>
// #include <sys/types.h>
// #include <unistd.h>
//
// int
// my_sd_pid_get_owner_uid(void *f, pid_t pid, uid_t *uid)
// {
//   int (*sd_pid_get_owner_uid)(pid_t, uid_t *);
//
//   sd_pid_get_owner_uid = (int (*)(pid_t, uid_t *))f;
//   return sd_pid_get_owner_uid(pid, uid);
// }
//
// int
// my_sd_pid_get_unit(void *f, pid_t pid, char **unit)
// {
//   int (*sd_pid_get_unit)(pid_t, char **);
//
//   sd_pid_get_unit = (int (*)(pid_t, char **))f;
//   return sd_pid_get_unit(pid, unit);
// }
//
// int
// my_sd_pid_get_slice(void *f, pid_t pid, char **slice)
// {
//   int (*sd_pid_get_slice)(pid_t, char **);
//
//   sd_pid_get_slice = (int (*)(pid_t, char **))f;
//   return sd_pid_get_slice(pid, slice);
// }
//
// int
// am_session_leader()
// {
//   return (getsid(0) == getpid());
// }
import _ "unsafe"
import (
	"fmt"
	"syscall"
	"unsafe"

	"github.com/coreos/go-systemd/internal/dlopen"
)

var libsystemdNames = []string{
	// systemd < 209
	"libsystemd-login.so.0",
	"libsystemd-login.so",

	// systemd >= 209 merged libsystemd-login into libsystemd proper
	"libsystemd.so.0",
	"libsystemd.so",
}

func getRunningSlice() (slice string, err error) {
	var h *dlopen.LibHandle
	h, err = dlopen.GetHandle(libsystemdNames)
	if err != nil {
		return
	}
	defer func() {
		if err1 := h.Close(); err1 != nil {
			err = err1
		}
	}()

	sd_pid_get_slice, err := h.GetSymbolPointer("sd_pid_get_slice")
	if err != nil {
		return
	}

	var s string
	sl := ( /*line :92:8*/_Cfunc_CString /*line :92:16*/)(s)
	defer func() func() { _cgo0 := /*line :93:15*/unsafe.Pointer(sl); return func() { _cgoCheckPointer(_cgo0, nil); /*line :93:34*/_Cfunc_free(_cgo0); }}()()

	ret := func() _Ctype_int{ _cgo0 := /*line :95:31*/sd_pid_get_slice; var _cgo1 _Ctype_pid_t = /*line :95:49*/0; _cgoBase2 := /*line :95:52*/&sl; _cgo2 := _cgoBase2; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase2, 0 == 0); return /*line :95:56*/_Cfunc_my_sd_pid_get_slice(_cgo0, _cgo1, _cgo2); }()
	if ret < 0 {
		err = fmt.Errorf("error calling sd_pid_get_slice: %v", syscall.Errno(-ret))
		return
	}

	return ( /*line :101:9*/_Cfunc_GoString /*line :101:18*/)(sl), nil
}

func runningFromSystemService() (ret bool, err error) {
	var h *dlopen.LibHandle
	h, err = dlopen.GetHandle(libsystemdNames)
	if err != nil {
		return
	}
	defer func() {
		if err1 := h.Close(); err1 != nil {
			err = err1
		}
	}()

	sd_pid_get_owner_uid, err := h.GetSymbolPointer("sd_pid_get_owner_uid")
	if err != nil {
		return
	}

	var uid  /*line :121:10*/_Ctype_uid_t /*line :121:17*/
	errno := func() _Ctype_int{ _cgo0 := /*line :122:37*/sd_pid_get_owner_uid; var _cgo1 _Ctype_pid_t = /*line :122:59*/0; var _cgo2 *_Ctype_uid_t = /*line :122:62*/&uid; _cgoCheckPointer(_cgo0, nil); return /*line :122:67*/_Cfunc_my_sd_pid_get_owner_uid(_cgo0, _cgo1, _cgo2); }()
	serrno := syscall.Errno(-errno)
	// when we're running from a unit file, sd_pid_get_owner_uid returns
	// ENOENT (systemd <220), ENXIO (systemd 220-223), or ENODATA
	// (systemd >=234)
	switch {
	case errno >= 0:
		ret = false
	case serrno == syscall.ENOENT, serrno == syscall.ENXIO, serrno == syscall.ENODATA:
		// Since the implementation of sessions in systemd relies on
		// the `pam_systemd` module, using the sd_pid_get_owner_uid
		// heuristic alone can result in false positives if that module
		// (or PAM itself) is not present or properly configured on the
		// system. As such, we also check if we're the session leader,
		// which should be the case if we're invoked from a unit file,
		// but not if e.g. we're invoked from the command line from a
		// user's login session
		ret = ( /*line :139:9*/_Cfunc_am_session_leader /*line :139:27*/)() == 1
	default:
		err = fmt.Errorf("error calling sd_pid_get_owner_uid: %v", syscall.Errno(-errno))
	}
	return
}

func currentUnitName() (unit string, err error) {
	var h *dlopen.LibHandle
	h, err = dlopen.GetHandle(libsystemdNames)
	if err != nil {
		return
	}
	defer func() {
		if err1 := h.Close(); err1 != nil {
			err = err1
		}
	}()

	sd_pid_get_unit, err := h.GetSymbolPointer("sd_pid_get_unit")
	if err != nil {
		return
	}

	var s string
	u := ( /*line :164:7*/_Cfunc_CString /*line :164:15*/)(s)
	defer func() func() { _cgo0 := /*line :165:15*/unsafe.Pointer(u); return func() { _cgoCheckPointer(_cgo0, nil); /*line :165:33*/_Cfunc_free(_cgo0); }}()()

	ret := func() _Ctype_int{ _cgo0 := /*line :167:30*/sd_pid_get_unit; var _cgo1 _Ctype_pid_t = /*line :167:47*/0; _cgoBase2 := /*line :167:50*/&u; _cgo2 := _cgoBase2; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase2, 0 == 0); return /*line :167:53*/_Cfunc_my_sd_pid_get_unit(_cgo0, _cgo1, _cgo2); }()
	if ret < 0 {
		err = fmt.Errorf("error calling sd_pid_get_unit: %v", syscall.Errno(-ret))
		return
	}

	unit = ( /*line :173:9*/_Cfunc_GoString /*line :173:18*/)(u)
	return
}
