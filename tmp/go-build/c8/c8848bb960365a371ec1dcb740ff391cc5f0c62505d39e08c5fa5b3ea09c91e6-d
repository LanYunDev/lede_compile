// Code generated by cmd/cgo; DO NOT EDIT.

//line /Volumes/2T/compile/lede/build_dir/target-x86_64_musl/containerd-1.7.6/.go_work/build/src/github.com/containerd/containerd/vendor/github.com/miekg/pkcs11/pkcs11.go:1:1
// Copyright 2013 Miek Gieben. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:generate go run const_generate.go

// Package pkcs11 is a wrapper around the PKCS#11 cryptographic library.
package pkcs11

// It is *assumed*, that:
//
// * Go's uint size == PKCS11's CK_ULONG size
// * CK_ULONG never overflows an Go int

/*
#cgo windows CFLAGS: -DPACKED_STRUCTURES
#cgo linux LDFLAGS: -ldl
#cgo darwin LDFLAGS: -ldl
#cgo openbsd LDFLAGS:
#cgo freebsd LDFLAGS: -ldl

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>

#include "pkcs11go.h"

#ifdef _WIN32
#include <windows.h>

struct ctx {
	HMODULE handle;
	CK_FUNCTION_LIST_PTR sym;
};

// New initializes a ctx and fills the symbol table.
struct ctx *New(const char *module)
{
	CK_C_GetFunctionList list;
	struct ctx *c = calloc(1, sizeof(struct ctx));
	c->handle = LoadLibrary(module);
	if (c->handle == NULL) {
		free(c);
		return NULL;
	}
	list = (CK_C_GetFunctionList) GetProcAddress(c->handle, "C_GetFunctionList");
	if (list == NULL) {
		free(c);
		return NULL;
	}
	list(&c->sym);
	return c;
}

// Destroy cleans up a ctx.
void Destroy(struct ctx *c)
{
	if (!c) {
		return;
	}
	free(c);
}
#else
#include <dlfcn.h>

struct ctx {
	void *handle;
	CK_FUNCTION_LIST_PTR sym;
};

// New initializes a ctx and fills the symbol table.
struct ctx *New(const char *module)
{
	CK_C_GetFunctionList list;
	struct ctx *c = calloc(1, sizeof(struct ctx));
	c->handle = dlopen(module, RTLD_LAZY);
	if (c->handle == NULL) {
		free(c);
		return NULL;
	}
	list = (CK_C_GetFunctionList) dlsym(c->handle, "C_GetFunctionList");
	if (list == NULL) {
		free(c);
		return NULL;
	}
	list(&c->sym);
	return c;
}

// Destroy cleans up a ctx.
void Destroy(struct ctx *c)
{
	if (!c) {
		return;
	}
	if (c->handle == NULL) {
		return;
	}
	if (dlclose(c->handle) < 0) {
		return;
	}
	free(c);
}
#endif

CK_RV Initialize(struct ctx * c)
{
	CK_C_INITIALIZE_ARGS args;
	memset(&args, 0, sizeof(args));
	args.flags = CKF_OS_LOCKING_OK;
	return c->sym->C_Initialize(&args);
}

CK_RV Finalize(struct ctx * c)
{
	return c->sym->C_Finalize(NULL);
}

CK_RV GetInfo(struct ctx * c, ckInfoPtr info)
{
	CK_INFO p;
	CK_RV e = c->sym->C_GetInfo(&p);
	if (e != CKR_OK) {
		return e;
	}
	info->cryptokiVersion = p.cryptokiVersion;
	memcpy(info->manufacturerID, p.manufacturerID, sizeof(p.manufacturerID));
	info->flags = p.flags;
	memcpy(info->libraryDescription, p.libraryDescription, sizeof(p.libraryDescription));
	info->libraryVersion = p.libraryVersion;
	return e;
}

CK_RV GetSlotList(struct ctx * c, CK_BBOOL tokenPresent,
		  CK_ULONG_PTR * slotList, CK_ULONG_PTR ulCount)
{
	CK_RV e = c->sym->C_GetSlotList(tokenPresent, NULL, ulCount);
	if (e != CKR_OK) {
		return e;
	}
	*slotList = calloc(*ulCount, sizeof(CK_SLOT_ID));
	e = c->sym->C_GetSlotList(tokenPresent, *slotList, ulCount);
	return e;
}

CK_RV GetSlotInfo(struct ctx * c, CK_ULONG slotID, CK_SLOT_INFO_PTR info)
{
	CK_RV e = c->sym->C_GetSlotInfo((CK_SLOT_ID) slotID, info);
	return e;
}

CK_RV GetTokenInfo(struct ctx * c, CK_ULONG slotID, CK_TOKEN_INFO_PTR info)
{
	CK_RV e = c->sym->C_GetTokenInfo((CK_SLOT_ID) slotID, info);
	return e;
}

CK_RV GetMechanismList(struct ctx * c, CK_ULONG slotID,
		       CK_ULONG_PTR * mech, CK_ULONG_PTR mechlen)
{
	CK_RV e =
	    c->sym->C_GetMechanismList((CK_SLOT_ID) slotID, NULL, mechlen);
	// Gemaltos PKCS11 implementation returns CKR_BUFFER_TOO_SMALL on a NULL ptr instad of CKR_OK as the spec states.
	if (e != CKR_OK && e != CKR_BUFFER_TOO_SMALL) {
		return e;
	}
	*mech = calloc(*mechlen, sizeof(CK_MECHANISM_TYPE));
	e = c->sym->C_GetMechanismList((CK_SLOT_ID) slotID,
				       (CK_MECHANISM_TYPE_PTR) * mech, mechlen);
	return e;
}

CK_RV GetMechanismInfo(struct ctx * c, CK_ULONG slotID, CK_MECHANISM_TYPE mech,
		       CK_MECHANISM_INFO_PTR info)
{
	CK_RV e = c->sym->C_GetMechanismInfo((CK_SLOT_ID) slotID, mech, info);
	return e;
}

CK_RV InitToken(struct ctx * c, CK_ULONG slotID, char *pin, CK_ULONG pinlen,
		char *label)
{
	CK_RV e =
	    c->sym->C_InitToken((CK_SLOT_ID) slotID, (CK_UTF8CHAR_PTR) pin,
				pinlen, (CK_UTF8CHAR_PTR) label);
	return e;
}

CK_RV InitPIN(struct ctx * c, CK_SESSION_HANDLE sh, char *pin, CK_ULONG pinlen)
{
	CK_RV e = c->sym->C_InitPIN(sh, (CK_UTF8CHAR_PTR) pin, pinlen);
	return e;
}

CK_RV SetPIN(struct ctx * c, CK_SESSION_HANDLE sh, char *oldpin,
	     CK_ULONG oldpinlen, char *newpin, CK_ULONG newpinlen)
{
	CK_RV e = c->sym->C_SetPIN(sh, (CK_UTF8CHAR_PTR) oldpin, oldpinlen,
				   (CK_UTF8CHAR_PTR) newpin, newpinlen);
	return e;
}

CK_RV OpenSession(struct ctx * c, CK_ULONG slotID, CK_ULONG flags,
		  CK_SESSION_HANDLE_PTR session)
{
	CK_RV e =
	    c->sym->C_OpenSession((CK_SLOT_ID) slotID, (CK_FLAGS) flags, NULL,
				  NULL, session);
	return e;
}

CK_RV CloseSession(struct ctx * c, CK_SESSION_HANDLE session)
{
	CK_RV e = c->sym->C_CloseSession(session);
	return e;
}

CK_RV CloseAllSessions(struct ctx * c, CK_ULONG slotID)
{
	CK_RV e = c->sym->C_CloseAllSessions(slotID);
	return e;
}

CK_RV GetSessionInfo(struct ctx * c, CK_SESSION_HANDLE session,
		     CK_SESSION_INFO_PTR info)
{
	CK_RV e = c->sym->C_GetSessionInfo(session, info);
	return e;
}

CK_RV GetOperationState(struct ctx * c, CK_SESSION_HANDLE session,
			CK_BYTE_PTR * state, CK_ULONG_PTR statelen)
{
	CK_RV rv = c->sym->C_GetOperationState(session, NULL, statelen);
	if (rv != CKR_OK) {
		return rv;
	}
	*state = calloc(*statelen, sizeof(CK_BYTE));
	if (*state == NULL) {
		return CKR_HOST_MEMORY;
	}
	rv = c->sym->C_GetOperationState(session, *state, statelen);
	return rv;
}

CK_RV SetOperationState(struct ctx * c, CK_SESSION_HANDLE session,
			CK_BYTE_PTR state, CK_ULONG statelen,
			CK_OBJECT_HANDLE encryptkey, CK_OBJECT_HANDLE authkey)
{
	return c->sym->C_SetOperationState(session, state, statelen, encryptkey,
					   authkey);
}

CK_RV Login(struct ctx *c, CK_SESSION_HANDLE session, CK_USER_TYPE userType,
	    char *pin, CK_ULONG pinLen)
{
	if (pinLen == 0) {
		pin = NULL;
	}
	CK_RV e =
	    c->sym->C_Login(session, userType, (CK_UTF8CHAR_PTR) pin, pinLen);
	return e;
}

CK_RV Logout(struct ctx * c, CK_SESSION_HANDLE session)
{
	CK_RV e = c->sym->C_Logout(session);
	return e;
}

CK_RV CreateObject(struct ctx * c, CK_SESSION_HANDLE session,
		   CK_ATTRIBUTE_PTR temp, CK_ULONG tempCount,
		   CK_OBJECT_HANDLE_PTR obj)
{
	return c->sym->C_CreateObject(session, temp, tempCount, obj);
}

CK_RV CopyObject(struct ctx * c, CK_SESSION_HANDLE session, CK_OBJECT_HANDLE o,
		 CK_ATTRIBUTE_PTR temp, CK_ULONG tempCount,
		 CK_OBJECT_HANDLE_PTR obj)
{
	return c->sym->C_CopyObject(session, o, temp, tempCount, obj);
}

CK_RV DestroyObject(struct ctx * c, CK_SESSION_HANDLE session,
		    CK_OBJECT_HANDLE object)
{
	CK_RV e = c->sym->C_DestroyObject(session, object);
	return e;
}

CK_RV GetObjectSize(struct ctx * c, CK_SESSION_HANDLE session,
		    CK_OBJECT_HANDLE object, CK_ULONG_PTR size)
{
	CK_RV e = c->sym->C_GetObjectSize(session, object, size);
	return e;
}

CK_RV GetAttributeValue(struct ctx * c, CK_SESSION_HANDLE session,
			CK_OBJECT_HANDLE object, CK_ATTRIBUTE_PTR temp,
			CK_ULONG templen)
{
	// Call for the first time, check the returned ulValue in the attributes, then
	// allocate enough space and try again.
	CK_RV e = c->sym->C_GetAttributeValue(session, object, temp, templen);
	if (e != CKR_OK) {
		return e;
	}
	CK_ULONG i;
	for (i = 0; i < templen; i++) {
		if ((CK_LONG) temp[i].ulValueLen == -1) {
			// either access denied or no such object
			continue;
		}
		temp[i].pValue = calloc(temp[i].ulValueLen, sizeof(CK_BYTE));
	}
	return c->sym->C_GetAttributeValue(session, object, temp, templen);
}

CK_RV SetAttributeValue(struct ctx * c, CK_SESSION_HANDLE session,
			CK_OBJECT_HANDLE object, CK_ATTRIBUTE_PTR temp,
			CK_ULONG templen)
{
	return c->sym->C_SetAttributeValue(session, object, temp, templen);
}

CK_RV FindObjectsInit(struct ctx * c, CK_SESSION_HANDLE session,
		      CK_ATTRIBUTE_PTR temp, CK_ULONG tempCount)
{
	return c->sym->C_FindObjectsInit(session, temp, tempCount);
}

CK_RV FindObjects(struct ctx * c, CK_SESSION_HANDLE session,
		  CK_OBJECT_HANDLE_PTR * obj, CK_ULONG max,
		  CK_ULONG_PTR objCount)
{
	*obj = calloc(max, sizeof(CK_OBJECT_HANDLE));
	CK_RV e = c->sym->C_FindObjects(session, *obj, max, objCount);
	return e;
}

CK_RV FindObjectsFinal(struct ctx * c, CK_SESSION_HANDLE session)
{
	CK_RV e = c->sym->C_FindObjectsFinal(session);
	return e;
}

CK_RV EncryptInit(struct ctx * c, CK_SESSION_HANDLE session,
		  CK_MECHANISM_PTR mechanism, CK_OBJECT_HANDLE key)
{
	return c->sym->C_EncryptInit(session, mechanism, key);
}

CK_RV Encrypt(struct ctx * c, CK_SESSION_HANDLE session, CK_BYTE_PTR message,
	      CK_ULONG mlen, CK_BYTE_PTR * enc, CK_ULONG_PTR enclen)
{
	CK_RV rv = c->sym->C_Encrypt(session, message, mlen, NULL, enclen);
	if (rv != CKR_OK) {
		return rv;
	}
	*enc = calloc(*enclen, sizeof(CK_BYTE));
	if (*enc == NULL) {
		return CKR_HOST_MEMORY;
	}
	rv = c->sym->C_Encrypt(session, message, mlen, *enc, enclen);
	return rv;
}

CK_RV EncryptUpdate(struct ctx * c, CK_SESSION_HANDLE session,
		    CK_BYTE_PTR plain, CK_ULONG plainlen, CK_BYTE_PTR * cipher,
		    CK_ULONG_PTR cipherlen)
{
	CK_RV rv =
	    c->sym->C_EncryptUpdate(session, plain, plainlen, NULL, cipherlen);
	if (rv != CKR_OK) {
		return rv;
	}
	*cipher = calloc(*cipherlen, sizeof(CK_BYTE));
	if (*cipher == NULL) {
		return CKR_HOST_MEMORY;
	}
	rv = c->sym->C_EncryptUpdate(session, plain, plainlen, *cipher,
				     cipherlen);
	return rv;
}

CK_RV EncryptFinal(struct ctx * c, CK_SESSION_HANDLE session,
		   CK_BYTE_PTR * cipher, CK_ULONG_PTR cipherlen)
{
	CK_RV rv = c->sym->C_EncryptFinal(session, NULL, cipherlen);
	if (rv != CKR_OK) {
		return rv;
	}
	*cipher = calloc(*cipherlen, sizeof(CK_BYTE));
	if (*cipher == NULL) {
		return CKR_HOST_MEMORY;
	}
	rv = c->sym->C_EncryptFinal(session, *cipher, cipherlen);
	return rv;
}

CK_RV DecryptInit(struct ctx * c, CK_SESSION_HANDLE session,
		  CK_MECHANISM_PTR mechanism, CK_OBJECT_HANDLE key)
{
	return c->sym->C_DecryptInit(session, mechanism, key);
}

CK_RV Decrypt(struct ctx * c, CK_SESSION_HANDLE session, CK_BYTE_PTR cipher,
	      CK_ULONG clen, CK_BYTE_PTR * plain, CK_ULONG_PTR plainlen)
{
	CK_RV e = c->sym->C_Decrypt(session, cipher, clen, NULL, plainlen);
	if (e != CKR_OK) {
		return e;
	}
	*plain = calloc(*plainlen, sizeof(CK_BYTE));
	if (*plain == NULL) {
		return CKR_HOST_MEMORY;
	}
	e = c->sym->C_Decrypt(session, cipher, clen, *plain, plainlen);
	return e;
}

CK_RV DecryptUpdate(struct ctx * c, CK_SESSION_HANDLE session,
		    CK_BYTE_PTR cipher, CK_ULONG cipherlen, CK_BYTE_PTR * part,
		    CK_ULONG_PTR partlen)
{
	CK_RV rv =
	    c->sym->C_DecryptUpdate(session, cipher, cipherlen, NULL, partlen);
	if (rv != CKR_OK) {
		return rv;
	}
	*part = calloc(*partlen, sizeof(CK_BYTE));
	if (*part == NULL) {
		return CKR_HOST_MEMORY;
	}
	rv = c->sym->C_DecryptUpdate(session, cipher, cipherlen, *part,
				     partlen);
	return rv;
}

CK_RV DecryptFinal(struct ctx * c, CK_SESSION_HANDLE session,
		   CK_BYTE_PTR * plain, CK_ULONG_PTR plainlen)
{
	CK_RV rv = c->sym->C_DecryptFinal(session, NULL, plainlen);
	if (rv != CKR_OK) {
		return rv;
	}
	*plain = calloc(*plainlen, sizeof(CK_BYTE));
	if (*plain == NULL) {
		return CKR_HOST_MEMORY;
	}
	rv = c->sym->C_DecryptFinal(session, *plain, plainlen);
	return rv;
}

CK_RV DigestInit(struct ctx * c, CK_SESSION_HANDLE session,
		 CK_MECHANISM_PTR mechanism)
{
	return c->sym->C_DigestInit(session, mechanism);
}

CK_RV Digest(struct ctx * c, CK_SESSION_HANDLE session, CK_BYTE_PTR message,
	     CK_ULONG mlen, CK_BYTE_PTR * hash, CK_ULONG_PTR hashlen)
{
	CK_RV rv = c->sym->C_Digest(session, message, mlen, NULL, hashlen);
	if (rv != CKR_OK) {
		return rv;
	}
	*hash = calloc(*hashlen, sizeof(CK_BYTE));
	if (*hash == NULL) {
		return CKR_HOST_MEMORY;
	}
	rv = c->sym->C_Digest(session, message, mlen, *hash, hashlen);
	return rv;
}

CK_RV DigestUpdate(struct ctx * c, CK_SESSION_HANDLE session,
		   CK_BYTE_PTR message, CK_ULONG mlen)
{
	CK_RV rv = c->sym->C_DigestUpdate(session, message, mlen);
	return rv;
}

CK_RV DigestKey(struct ctx * c, CK_SESSION_HANDLE session, CK_OBJECT_HANDLE key)
{
	CK_RV rv = c->sym->C_DigestKey(session, key);
	return rv;
}

CK_RV DigestFinal(struct ctx * c, CK_SESSION_HANDLE session, CK_BYTE_PTR * hash,
		  CK_ULONG_PTR hashlen)
{
	CK_RV rv = c->sym->C_DigestFinal(session, NULL, hashlen);
	if (rv != CKR_OK) {
		return rv;
	}
	*hash = calloc(*hashlen, sizeof(CK_BYTE));
	if (*hash == NULL) {
		return CKR_HOST_MEMORY;
	}
	rv = c->sym->C_DigestFinal(session, *hash, hashlen);
	return rv;
}

CK_RV SignInit(struct ctx * c, CK_SESSION_HANDLE session,
	       CK_MECHANISM_PTR mechanism, CK_OBJECT_HANDLE key)
{
	return c->sym->C_SignInit(session, mechanism, key);
}

CK_RV Sign(struct ctx * c, CK_SESSION_HANDLE session, CK_BYTE_PTR message,
	   CK_ULONG mlen, CK_BYTE_PTR * sig, CK_ULONG_PTR siglen)
{
	CK_RV rv = c->sym->C_Sign(session, message, mlen, NULL, siglen);
	if (rv != CKR_OK) {
		return rv;
	}
	*sig = calloc(*siglen, sizeof(CK_BYTE));
	if (*sig == NULL) {
		return CKR_HOST_MEMORY;
	}
	rv = c->sym->C_Sign(session, message, mlen, *sig, siglen);
	return rv;
}

CK_RV SignUpdate(struct ctx * c, CK_SESSION_HANDLE session,
		 CK_BYTE_PTR message, CK_ULONG mlen)
{
	CK_RV rv = c->sym->C_SignUpdate(session, message, mlen);
	return rv;
}

CK_RV SignFinal(struct ctx * c, CK_SESSION_HANDLE session, CK_BYTE_PTR * sig,
		CK_ULONG_PTR siglen)
{
	CK_RV rv = c->sym->C_SignFinal(session, NULL, siglen);
	if (rv != CKR_OK) {
		return rv;
	}
	*sig = calloc(*siglen, sizeof(CK_BYTE));
	if (*sig == NULL) {
		return CKR_HOST_MEMORY;
	}
	rv = c->sym->C_SignFinal(session, *sig, siglen);
	return rv;
}

CK_RV SignRecoverInit(struct ctx * c, CK_SESSION_HANDLE session,
		      CK_MECHANISM_PTR mechanism, CK_OBJECT_HANDLE key)
{
	return c->sym->C_SignRecoverInit(session, mechanism, key);
}

CK_RV SignRecover(struct ctx * c, CK_SESSION_HANDLE session, CK_BYTE_PTR data,
		  CK_ULONG datalen, CK_BYTE_PTR * sig, CK_ULONG_PTR siglen)
{
	CK_RV rv = c->sym->C_SignRecover(session, data, datalen, NULL, siglen);
	if (rv != CKR_OK) {
		return rv;
	}
	*sig = calloc(*siglen, sizeof(CK_BYTE));
	if (*sig == NULL) {
		return CKR_HOST_MEMORY;
	}
	rv = c->sym->C_SignRecover(session, data, datalen, *sig, siglen);
	return rv;
}

CK_RV VerifyInit(struct ctx * c, CK_SESSION_HANDLE session,
		 CK_MECHANISM_PTR mechanism, CK_OBJECT_HANDLE key)
{
	return c->sym->C_VerifyInit(session, mechanism, key);
}

CK_RV Verify(struct ctx * c, CK_SESSION_HANDLE session, CK_BYTE_PTR message,
	     CK_ULONG mesglen, CK_BYTE_PTR sig, CK_ULONG siglen)
{
	CK_RV rv = c->sym->C_Verify(session, message, mesglen, sig, siglen);
	return rv;
}

CK_RV VerifyUpdate(struct ctx * c, CK_SESSION_HANDLE session,
		   CK_BYTE_PTR part, CK_ULONG partlen)
{
	CK_RV rv = c->sym->C_VerifyUpdate(session, part, partlen);
	return rv;
}

CK_RV VerifyFinal(struct ctx * c, CK_SESSION_HANDLE session, CK_BYTE_PTR sig,
		  CK_ULONG siglen)
{
	CK_RV rv = c->sym->C_VerifyFinal(session, sig, siglen);
	return rv;
}

CK_RV VerifyRecoverInit(struct ctx * c, CK_SESSION_HANDLE session,
			CK_MECHANISM_PTR mechanism, CK_OBJECT_HANDLE key)
{
	return c->sym->C_VerifyRecoverInit(session, mechanism, key);
}

CK_RV VerifyRecover(struct ctx * c, CK_SESSION_HANDLE session, CK_BYTE_PTR sig,
		    CK_ULONG siglen, CK_BYTE_PTR * data, CK_ULONG_PTR datalen)
{
	CK_RV rv = c->sym->C_VerifyRecover(session, sig, siglen, NULL, datalen);
	if (rv != CKR_OK) {
		return rv;
	}
	*data = calloc(*datalen, sizeof(CK_BYTE));
	if (*data == NULL) {
		return CKR_HOST_MEMORY;
	}
	rv = c->sym->C_VerifyRecover(session, sig, siglen, *data, datalen);
	return rv;
}

CK_RV DigestEncryptUpdate(struct ctx * c, CK_SESSION_HANDLE session,
			  CK_BYTE_PTR part, CK_ULONG partlen, CK_BYTE_PTR * enc,
			  CK_ULONG_PTR enclen)
{
	CK_RV rv =
	    c->sym->C_DigestEncryptUpdate(session, part, partlen, NULL, enclen);
	if (rv != CKR_OK) {
		return rv;
	}
	*enc = calloc(*enclen, sizeof(CK_BYTE));
	if (*enc == NULL) {
		return CKR_HOST_MEMORY;
	}
	rv = c->sym->C_DigestEncryptUpdate(session, part, partlen, *enc,
					   enclen);
	return rv;
}

CK_RV DecryptDigestUpdate(struct ctx * c, CK_SESSION_HANDLE session,
			  CK_BYTE_PTR cipher, CK_ULONG cipherlen,
			  CK_BYTE_PTR * part, CK_ULONG_PTR partlen)
{
	CK_RV rv =
	    c->sym->C_DecryptDigestUpdate(session, cipher, cipherlen, NULL,
					  partlen);
	if (rv != CKR_OK) {
		return rv;
	}
	*part = calloc(*partlen, sizeof(CK_BYTE));
	if (*part == NULL) {
		return CKR_HOST_MEMORY;
	}
	rv = c->sym->C_DecryptDigestUpdate(session, cipher, cipherlen, *part,
					   partlen);
	return rv;
}

CK_RV SignEncryptUpdate(struct ctx * c, CK_SESSION_HANDLE session,
			CK_BYTE_PTR part, CK_ULONG partlen, CK_BYTE_PTR * enc,
			CK_ULONG_PTR enclen)
{
	CK_RV rv =
	    c->sym->C_SignEncryptUpdate(session, part, partlen, NULL, enclen);
	if (rv != CKR_OK) {
		return rv;
	}
	*enc = calloc(*enclen, sizeof(CK_BYTE));
	if (*enc == NULL) {
		return CKR_HOST_MEMORY;
	}
	rv = c->sym->C_SignEncryptUpdate(session, part, partlen, *enc, enclen);
	return rv;
}

CK_RV DecryptVerifyUpdate(struct ctx * c, CK_SESSION_HANDLE session,
			  CK_BYTE_PTR cipher, CK_ULONG cipherlen,
			  CK_BYTE_PTR * part, CK_ULONG_PTR partlen)
{
	CK_RV rv =
	    c->sym->C_DecryptVerifyUpdate(session, cipher, cipherlen, NULL,
					  partlen);
	if (rv != CKR_OK) {
		return rv;
	}
	*part = calloc(*partlen, sizeof(CK_BYTE));
	if (*part == NULL) {
		return CKR_HOST_MEMORY;
	}
	rv = c->sym->C_DecryptVerifyUpdate(session, cipher, cipherlen, *part,
					   partlen);
	return rv;
}

CK_RV GenerateKey(struct ctx * c, CK_SESSION_HANDLE session,
		  CK_MECHANISM_PTR mechanism, CK_ATTRIBUTE_PTR temp,
		  CK_ULONG tempCount, CK_OBJECT_HANDLE_PTR key)
{
	return c->sym->C_GenerateKey(session, mechanism, temp, tempCount, key);
}

CK_RV GenerateKeyPair(struct ctx * c, CK_SESSION_HANDLE session,
		      CK_MECHANISM_PTR mechanism, CK_ATTRIBUTE_PTR pub,
		      CK_ULONG pubCount, CK_ATTRIBUTE_PTR priv,
		      CK_ULONG privCount, CK_OBJECT_HANDLE_PTR pubkey,
		      CK_OBJECT_HANDLE_PTR privkey)
{
	return c->sym->C_GenerateKeyPair(session, mechanism, pub, pubCount,
		priv, privCount, pubkey, privkey);
}

CK_RV WrapKey(struct ctx * c, CK_SESSION_HANDLE session,
	      CK_MECHANISM_PTR mechanism, CK_OBJECT_HANDLE wrappingkey,
	      CK_OBJECT_HANDLE key, CK_BYTE_PTR * wrapped,
	      CK_ULONG_PTR wrappedlen)
{
	CK_RV rv = c->sym->C_WrapKey(session, mechanism, wrappingkey, key, NULL,
				     wrappedlen);
	if (rv != CKR_OK) {
		return rv;
	}
	*wrapped = calloc(*wrappedlen, sizeof(CK_BYTE));
	if (*wrapped == NULL) {
		return CKR_HOST_MEMORY;
	}
	rv = c->sym->C_WrapKey(session, mechanism, wrappingkey, key, *wrapped,
			       wrappedlen);
	return rv;
}

CK_RV DeriveKey(struct ctx * c, CK_SESSION_HANDLE session,
		CK_MECHANISM_PTR mechanism, CK_OBJECT_HANDLE basekey,
		CK_ATTRIBUTE_PTR a, CK_ULONG alen, CK_OBJECT_HANDLE_PTR key)
{
	return c->sym->C_DeriveKey(session, mechanism, basekey, a, alen, key);
}

CK_RV UnwrapKey(struct ctx * c, CK_SESSION_HANDLE session,
		CK_MECHANISM_PTR mechanism, CK_OBJECT_HANDLE unwrappingkey,
		CK_BYTE_PTR wrappedkey, CK_ULONG wrappedkeylen,
		CK_ATTRIBUTE_PTR a, CK_ULONG alen, CK_OBJECT_HANDLE_PTR key)
{
	return c->sym->C_UnwrapKey(session, mechanism, unwrappingkey, wrappedkey,
				      wrappedkeylen, a, alen, key);
}

CK_RV SeedRandom(struct ctx * c, CK_SESSION_HANDLE session, CK_BYTE_PTR seed,
		 CK_ULONG seedlen)
{
	CK_RV e = c->sym->C_SeedRandom(session, seed, seedlen);
	return e;
}

CK_RV GenerateRandom(struct ctx * c, CK_SESSION_HANDLE session,
		     CK_BYTE_PTR * rand, CK_ULONG length)
{
	*rand = calloc(length, sizeof(CK_BYTE));
	if (*rand == NULL) {
		return CKR_HOST_MEMORY;
	}
	CK_RV e = c->sym->C_GenerateRandom(session, *rand, length);
	return e;
}

CK_RV WaitForSlotEvent(struct ctx * c, CK_FLAGS flags, CK_ULONG_PTR slot)
{
	CK_RV e =
	    c->sym->C_WaitForSlotEvent(flags, (CK_SLOT_ID_PTR) slot, NULL);
	return e;
}

static inline CK_VOID_PTR getAttributePval(CK_ATTRIBUTE_PTR a)
{
	return a->pValue;
}

*/
import _ "unsafe"
import (
	"strings"
	"unsafe"
)

// Ctx contains the current pkcs11 context.
type Ctx struct {
	ctx * /*line :782:7*/_Ctype_struct_ctx /*line :782:19*/
}

// New creates a new context and initializes the module/library for use.
func New(module string) *Ctx {
	c := new(Ctx)
	mod := ( /*line :788:9*/_Cfunc_CString /*line :788:17*/)(module)
	defer func() func() { _cgo0 := /*line :789:15*/unsafe.Pointer(mod); return func() { _cgoCheckPointer(_cgo0, nil); /*line :789:35*/_Cfunc_free(_cgo0); }}()()
	c.ctx = ( /*line :790:10*/_Cfunc_New /*line :790:14*/)(mod)
	if c.ctx == nil {
		return nil
	}
	return c
}

// Destroy unloads the module/library and frees any remaining memory.
func (c *Ctx) Destroy() {
	if c == nil || c.ctx == nil {
		return
	}
	func() { _cgo0 := /*line :802:12*/c.ctx; _cgoCheckPointer(_cgo0, nil); /*line :802:18*/_Cfunc_Destroy(_cgo0); }()
	c.ctx = nil
}

// Initialize initializes the Cryptoki library.
func (c *Ctx) Initialize() error {
	e := func() _Ctype_CK_RV{ _cgo0 := /*line :808:20*/c.ctx; _cgoCheckPointer(_cgo0, nil); return /*line :808:26*/_Cfunc_Initialize(_cgo0); }()
	return toError(e)
}

// Finalize indicates that an application is done with the Cryptoki library.
func (c *Ctx) Finalize() error {
	if c.ctx == nil {
		return toError(CKR_CRYPTOKI_NOT_INITIALIZED)
	}
	e := func() _Ctype_CK_RV{ _cgo0 := /*line :817:18*/c.ctx; _cgoCheckPointer(_cgo0, nil); return /*line :817:24*/_Cfunc_Finalize(_cgo0); }()
	return toError(e)
}

// GetInfo returns general information about Cryptoki.
func (c *Ctx) GetInfo() (Info, error) {
	var p  /*line :823:8*/_Ctype_ckInfo /*line :823:16*/
	e := func() _Ctype_CK_RV{ _cgo0 := /*line :824:17*/c.ctx; var _cgo1 *_Ctype_struct_ckInfo = /*line :824:24*/&p; _cgoCheckPointer(_cgo0, nil); return /*line :824:27*/_Cfunc_GetInfo(_cgo0, _cgo1); }()
	i := Info{
		CryptokiVersion:    toVersion(p.cryptokiVersion),
		ManufacturerID:     strings.TrimRight(string(func() []byte{ _cgoIndex0 := &/*line :827:74*/p.manufacturerID; _cgo0 := /*line :827:58*/unsafe.Pointer(&(*_cgoIndex0)[0]); var _cgo1 _Ctype_int = /*line :827:96*/32; _cgoCheckPointer(_cgo0, *_cgoIndex0); return /*line :827:99*/_Cfunc_GoBytes(_cgo0, _cgo1); }()), " "),
		Flags:              uint(p.flags),
		LibraryDescription: strings.TrimRight(string(func() []byte{ _cgoIndex0 := &/*line :829:74*/p.libraryDescription; _cgo0 := /*line :829:58*/unsafe.Pointer(&(*_cgoIndex0)[0]); var _cgo1 _Ctype_int = /*line :829:100*/32; _cgoCheckPointer(_cgo0, *_cgoIndex0); return /*line :829:103*/_Cfunc_GoBytes(_cgo0, _cgo1); }()), " "),
		LibraryVersion:     toVersion(p.libraryVersion),
	}
	return i, toError(e)
}

// GetSlotList obtains a list of slots in the system.
func (c *Ctx) GetSlotList(tokenPresent bool) ([]uint, error) {
	var (
		slotList  /*line :838:12*/_Ctype_CK_ULONG_PTR /*line :838:26*/
		ulCount   /*line :839:12*/_Ctype_CK_ULONG /*line :839:22*/
	)
	e := func() _Ctype_CK_RV{ _cgo0 := /*line :841:21*/c.ctx; var _cgo1 _Ctype_CK_BBOOL = /*line :841:28*/cBBool(tokenPresent); _cgoBase2 := /*line :841:50*/&slotList; _cgo2 := _cgoBase2; var _cgo3 *_Ctype_CK_ULONG = /*line :841:61*/&ulCount; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase2, 0 == 0); return /*line :841:70*/_Cfunc_GetSlotList(_cgo0, _cgo1, _cgo2, _cgo3); }()
	if toError(e) != nil {
		return nil, toError(e)
	}
	l := toList(slotList, ulCount)
	return l, nil
}

// GetSlotInfo obtains information about a particular slot in the system.
func (c *Ctx) GetSlotInfo(slotID uint) (SlotInfo, error) {
	var csi  /*line :851:10*/_Ctype_CK_SLOT_INFO /*line :851:24*/
	e := func() _Ctype_CK_RV{ _cgo0 := /*line :852:21*/c.ctx; var _cgo1 _Ctype_CK_ULONG = _Ctype_CK_ULONG /*line :852:38*/(slotID); var _cgo2 *_Ctype_struct_CK_SLOT_INFO = /*line :852:48*/&csi; _cgoCheckPointer(_cgo0, nil); return /*line :852:53*/_Cfunc_GetSlotInfo(_cgo0, _cgo1, _cgo2); }()
	s := SlotInfo{
		SlotDescription: strings.TrimRight(string(func() []byte{ _cgoIndex0 := &/*line :854:71*/csi.slotDescription; _cgo0 := /*line :854:55*/unsafe.Pointer(&(*_cgoIndex0)[0]); var _cgo1 _Ctype_int = /*line :854:96*/64; _cgoCheckPointer(_cgo0, *_cgoIndex0); return /*line :854:99*/_Cfunc_GoBytes(_cgo0, _cgo1); }()), " "),
		ManufacturerID:  strings.TrimRight(string(func() []byte{ _cgoIndex0 := &/*line :855:71*/csi.manufacturerID; _cgo0 := /*line :855:55*/unsafe.Pointer(&(*_cgoIndex0)[0]); var _cgo1 _Ctype_int = /*line :855:95*/32; _cgoCheckPointer(_cgo0, *_cgoIndex0); return /*line :855:98*/_Cfunc_GoBytes(_cgo0, _cgo1); }()), " "),
		Flags:           uint(csi.flags),
		HardwareVersion: toVersion(csi.hardwareVersion),
		FirmwareVersion: toVersion(csi.firmwareVersion),
	}
	return s, toError(e)
}

// GetTokenInfo obtains information about a particular token
// in the system.
func (c *Ctx) GetTokenInfo(slotID uint) (TokenInfo, error) {
	var cti  /*line :866:10*/_Ctype_CK_TOKEN_INFO /*line :866:25*/
	e := func() _Ctype_CK_RV{ _cgo0 := /*line :867:22*/c.ctx; var _cgo1 _Ctype_CK_ULONG = _Ctype_CK_ULONG /*line :867:39*/(slotID); var _cgo2 *_Ctype_struct_CK_TOKEN_INFO = /*line :867:49*/&cti; _cgoCheckPointer(_cgo0, nil); return /*line :867:54*/_Cfunc_GetTokenInfo(_cgo0, _cgo1, _cgo2); }()
	s := TokenInfo{
		Label:              strings.TrimRight(string(func() []byte{ _cgoIndex0 := &/*line :869:74*/cti.label; _cgo0 := /*line :869:58*/unsafe.Pointer(&(*_cgoIndex0)[0]); var _cgo1 _Ctype_int = /*line :869:89*/32; _cgoCheckPointer(_cgo0, *_cgoIndex0); return /*line :869:92*/_Cfunc_GoBytes(_cgo0, _cgo1); }()), " "),
		ManufacturerID:     strings.TrimRight(string(func() []byte{ _cgoIndex0 := &/*line :870:74*/cti.manufacturerID; _cgo0 := /*line :870:58*/unsafe.Pointer(&(*_cgoIndex0)[0]); var _cgo1 _Ctype_int = /*line :870:98*/32; _cgoCheckPointer(_cgo0, *_cgoIndex0); return /*line :870:101*/_Cfunc_GoBytes(_cgo0, _cgo1); }()), " "),
		Model:              strings.TrimRight(string(func() []byte{ _cgoIndex0 := &/*line :871:74*/cti.model; _cgo0 := /*line :871:58*/unsafe.Pointer(&(*_cgoIndex0)[0]); var _cgo1 _Ctype_int = /*line :871:89*/16; _cgoCheckPointer(_cgo0, *_cgoIndex0); return /*line :871:92*/_Cfunc_GoBytes(_cgo0, _cgo1); }()), " "),
		SerialNumber:       strings.TrimRight(string(func() []byte{ _cgoIndex0 := &/*line :872:74*/cti.serialNumber; _cgo0 := /*line :872:58*/unsafe.Pointer(&(*_cgoIndex0)[0]); var _cgo1 _Ctype_int = /*line :872:96*/16; _cgoCheckPointer(_cgo0, *_cgoIndex0); return /*line :872:99*/_Cfunc_GoBytes(_cgo0, _cgo1); }()), " "),
		Flags:              uint(cti.flags),
		MaxSessionCount:    uint(cti.ulMaxSessionCount),
		SessionCount:       uint(cti.ulSessionCount),
		MaxRwSessionCount:  uint(cti.ulMaxRwSessionCount),
		RwSessionCount:     uint(cti.ulRwSessionCount),
		MaxPinLen:          uint(cti.ulMaxPinLen),
		MinPinLen:          uint(cti.ulMinPinLen),
		TotalPublicMemory:  uint(cti.ulTotalPublicMemory),
		FreePublicMemory:   uint(cti.ulFreePublicMemory),
		TotalPrivateMemory: uint(cti.ulTotalPrivateMemory),
		FreePrivateMemory:  uint(cti.ulFreePrivateMemory),
		HardwareVersion:    toVersion(cti.hardwareVersion),
		FirmwareVersion:    toVersion(cti.firmwareVersion),
		UTCTime:            strings.TrimRight(string(func() []byte{ _cgoIndex0 := &/*line :886:74*/cti.utcTime; _cgo0 := /*line :886:58*/unsafe.Pointer(&(*_cgoIndex0)[0]); var _cgo1 _Ctype_int = /*line :886:91*/16; _cgoCheckPointer(_cgo0, *_cgoIndex0); return /*line :886:94*/_Cfunc_GoBytes(_cgo0, _cgo1); }()), " "),
	}
	return s, toError(e)
}

// GetMechanismList obtains a list of mechanism types supported by a token.
func (c *Ctx) GetMechanismList(slotID uint) ([]*Mechanism, error) {
	var (
		mech     /*line :894:11*/_Ctype_CK_ULONG_PTR /*line :894:25*/ // in pkcs#11 we're all CK_ULONGs \o/
		mechlen  /*line :895:11*/_Ctype_CK_ULONG /*line :895:21*/
	)
	e := func() _Ctype_CK_RV{ _cgo0 := /*line :897:26*/c.ctx; var _cgo1 _Ctype_CK_ULONG = _Ctype_CK_ULONG /*line :897:43*/(slotID); _cgoBase2 := /*line :897:53*/&mech; _cgo2 := _cgoBase2; var _cgo3 *_Ctype_CK_ULONG = /*line :897:60*/&mechlen; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase2, 0 == 0); return /*line :897:69*/_Cfunc_GetMechanismList(_cgo0, _cgo1, _cgo2, _cgo3); }()
	if toError(e) != nil {
		return nil, toError(e)
	}
	// Although the function returns only type, cast them back into real
	// attributes as this is used in other functions.
	m := make([]*Mechanism, int(mechlen))
	for i, typ := range toList(mech, mechlen) {
		m[i] = NewMechanism(typ, nil)
	}
	return m, nil
}

// GetMechanismInfo obtains information about a particular
// mechanism possibly supported by a token.
func (c *Ctx) GetMechanismInfo(slotID uint, m []*Mechanism) (MechanismInfo, error) {
	var cm  /*line :913:9*/_Ctype_CK_MECHANISM_INFO /*line :913:28*/
	e := func() _Ctype_CK_RV{ _cgo0 := /*line :914:26*/c.ctx; var _cgo1 _Ctype_CK_ULONG = _Ctype_CK_ULONG /*line :914:43*/(slotID); var _cgo2 _Ctype_CK_MECHANISM_TYPE = _Ctype_CK_MECHANISM_TYPE /*line :914:72*/(m[0].Mechanism); var _cgo3 *_Ctype_struct_CK_MECHANISM_INFO = _Ctype_CK_MECHANISM_INFO_PTR /*line :915:26*/(&cm); _cgoCheckPointer(_cgo0, nil); return /*line :915:32*/_Cfunc_GetMechanismInfo(_cgo0, _cgo1, _cgo2, _cgo3); }()
	mi := MechanismInfo{
		MinKeySize: uint(cm.ulMinKeySize),
		MaxKeySize: uint(cm.ulMaxKeySize),
		Flags:      uint(cm.flags),
	}
	return mi, toError(e)
}

// InitToken initializes a token. The label must be 32 characters
// long, it is blank padded if it is not. If it is longer it is capped
// to 32 characters.
func (c *Ctx) InitToken(slotID uint, pin string, label string) error {
	p := ( /*line :928:7*/_Cfunc_CString /*line :928:15*/)(pin)
	defer func() func() { _cgo0 := /*line :929:15*/unsafe.Pointer(p); return func() { _cgoCheckPointer(_cgo0, nil); /*line :929:33*/_Cfunc_free(_cgo0); }}()()
	ll := len(label)
	for ll < 32 {
		label += " "
		ll++
	}
	l := ( /*line :935:7*/_Cfunc_CString /*line :935:15*/)(label[:32])
	defer func() func() { _cgo0 := /*line :936:15*/unsafe.Pointer(l); return func() { _cgoCheckPointer(_cgo0, nil); /*line :936:33*/_Cfunc_free(_cgo0); }}()()
	e := func() _Ctype_CK_RV{ _cgo0 := /*line :937:19*/c.ctx; var _cgo1 _Ctype_CK_ULONG = _Ctype_CK_ULONG /*line :937:36*/(slotID); var _cgo2 *_Ctype_char = /*line :937:46*/p; var _cgo3 _Ctype_CK_ULONG = _Ctype_CK_ULONG /*line :937:59*/(len(pin)); var _cgo4 *_Ctype_char = /*line :937:71*/l; _cgoCheckPointer(_cgo0, nil); return /*line :937:73*/_Cfunc_InitToken(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }()
	return toError(e)
}

// InitPIN initializes the normal user's PIN.
func (c *Ctx) InitPIN(sh SessionHandle, pin string) error {
	p := ( /*line :943:7*/_Cfunc_CString /*line :943:15*/)(pin)
	defer func() func() { _cgo0 := /*line :944:15*/unsafe.Pointer(p); return func() { _cgoCheckPointer(_cgo0, nil); /*line :944:33*/_Cfunc_free(_cgo0); }}()()
	e := func() _Ctype_CK_RV{ _cgo0 := /*line :945:17*/c.ctx; var _cgo1 _Ctype_CK_SESSION_HANDLE = _Ctype_CK_SESSION_HANDLE /*line :945:43*/(sh); var _cgo2 *_Ctype_char = /*line :945:49*/p; var _cgo3 _Ctype_CK_ULONG = _Ctype_CK_ULONG /*line :945:62*/(len(pin)); _cgoCheckPointer(_cgo0, nil); return /*line :945:73*/_Cfunc_InitPIN(_cgo0, _cgo1, _cgo2, _cgo3); }()
	return toError(e)
}

// SetPIN modifies the PIN of the user who is logged in.
func (c *Ctx) SetPIN(sh SessionHandle, oldpin string, newpin string) error {
	old := ( /*line :951:9*/_Cfunc_CString /*line :951:17*/)(oldpin)
	defer func() func() { _cgo0 := /*line :952:15*/unsafe.Pointer(old); return func() { _cgoCheckPointer(_cgo0, nil); /*line :952:35*/_Cfunc_free(_cgo0); }}()()
	new := ( /*line :953:9*/_Cfunc_CString /*line :953:17*/)(newpin)
	defer func() func() { _cgo0 := /*line :954:15*/unsafe.Pointer(new); return func() { _cgoCheckPointer(_cgo0, nil); /*line :954:35*/_Cfunc_free(_cgo0); }}()()
	e := func() _Ctype_CK_RV{ _cgo0 := /*line :955:16*/c.ctx; var _cgo1 _Ctype_CK_SESSION_HANDLE = _Ctype_CK_SESSION_HANDLE /*line :955:42*/(sh); var _cgo2 *_Ctype_char = /*line :955:48*/old; var _cgo3 _Ctype_CK_ULONG = _Ctype_CK_ULONG /*line :955:63*/(len(oldpin)); var _cgo4 *_Ctype_char = /*line :955:78*/new; var _cgo5 _Ctype_CK_ULONG = _Ctype_CK_ULONG /*line :955:93*/(len(newpin)); _cgoCheckPointer(_cgo0, nil); return /*line :955:107*/_Cfunc_SetPIN(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5); }()
	return toError(e)
}

// OpenSession opens a session between an application and a token.
func (c *Ctx) OpenSession(slotID uint, flags uint) (SessionHandle, error) {
	var s  /*line :961:8*/_Ctype_CK_SESSION_HANDLE /*line :961:27*/
	e := func() _Ctype_CK_RV{ _cgo0 := /*line :962:21*/c.ctx; var _cgo1 _Ctype_CK_ULONG = _Ctype_CK_ULONG /*line :962:38*/(slotID); var _cgo2 _Ctype_CK_ULONG = _Ctype_CK_ULONG /*line :962:58*/(flags); var _cgo3 *_Ctype_CK_SESSION_HANDLE = _Ctype_CK_SESSION_HANDLE_PTR /*line :962:90*/(&s); _cgoCheckPointer(_cgo0, nil); return /*line :962:95*/_Cfunc_OpenSession(_cgo0, _cgo1, _cgo2, _cgo3); }()
	return SessionHandle(s), toError(e)
}

// CloseSession closes a session between an application and a token.
func (c *Ctx) CloseSession(sh SessionHandle) error {
	if c.ctx == nil {
		return toError(CKR_CRYPTOKI_NOT_INITIALIZED)
	}
	e := func() _Ctype_CK_RV{ _cgo0 := /*line :971:22*/c.ctx; var _cgo1 _Ctype_CK_SESSION_HANDLE = _Ctype_CK_SESSION_HANDLE /*line :971:48*/(sh); _cgoCheckPointer(_cgo0, nil); return /*line :971:53*/_Cfunc_CloseSession(_cgo0, _cgo1); }()
	return toError(e)
}

// CloseAllSessions closes all sessions with a token.
func (c *Ctx) CloseAllSessions(slotID uint) error {
	if c.ctx == nil {
		return toError(CKR_CRYPTOKI_NOT_INITIALIZED)
	}
	e := func() _Ctype_CK_RV{ _cgo0 := /*line :980:26*/c.ctx; var _cgo1 _Ctype_CK_ULONG = _Ctype_CK_ULONG /*line :980:43*/(slotID); _cgoCheckPointer(_cgo0, nil); return /*line :980:52*/_Cfunc_CloseAllSessions(_cgo0, _cgo1); }()
	return toError(e)
}

// GetSessionInfo obtains information about the session.
func (c *Ctx) GetSessionInfo(sh SessionHandle) (SessionInfo, error) {
	var csi  /*line :986:10*/_Ctype_CK_SESSION_INFO /*line :986:27*/
	e := func() _Ctype_CK_RV{ _cgo0 := /*line :987:24*/c.ctx; var _cgo1 _Ctype_CK_SESSION_HANDLE = _Ctype_CK_SESSION_HANDLE /*line :987:50*/(sh); var _cgo2 *_Ctype_struct_CK_SESSION_INFO = /*line :987:56*/&csi; _cgoCheckPointer(_cgo0, nil); return /*line :987:61*/_Cfunc_GetSessionInfo(_cgo0, _cgo1, _cgo2); }()
	s := SessionInfo{SlotID: uint(csi.slotID),
		State:       uint(csi.state),
		Flags:       uint(csi.flags),
		DeviceError: uint(csi.ulDeviceError),
	}
	return s, toError(e)
}

// GetOperationState obtains the state of the cryptographic operation in a session.
func (c *Ctx) GetOperationState(sh SessionHandle) ([]byte, error) {
	var (
		state     /*line :999:12*/_Ctype_CK_BYTE_PTR /*line :999:25*/
		statelen  /*line :1000:12*/_Ctype_CK_ULONG /*line :1000:22*/
	)
	e := func() _Ctype_CK_RV{ _cgo0 := /*line :1002:27*/c.ctx; var _cgo1 _Ctype_CK_SESSION_HANDLE = _Ctype_CK_SESSION_HANDLE /*line :1002:53*/(sh); _cgoBase2 := /*line :1002:59*/&state; _cgo2 := _cgoBase2; var _cgo3 *_Ctype_CK_ULONG = /*line :1002:67*/&statelen; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase2, 0 == 0); return /*line :1002:77*/_Cfunc_GetOperationState(_cgo0, _cgo1, _cgo2, _cgo3); }()
	defer func() func() { _cgo0 := /*line :1003:15*/unsafe.Pointer(state); return func() { _cgoCheckPointer(_cgo0, nil); /*line :1003:37*/_Cfunc_free(_cgo0); }}()()
	if toError(e) != nil {
		return nil, toError(e)
	}
	b := func() []byte{ _cgo0 := /*line :1007:17*/unsafe.Pointer(state); var _cgo1 _Ctype_int = _Ctype_int /*line :1007:45*/(statelen); _cgoCheckPointer(_cgo0, nil); return /*line :1007:56*/_Cfunc_GoBytes(_cgo0, _cgo1); }()
	return b, nil
}

// SetOperationState restores the state of the cryptographic operation in a session.
func (c *Ctx) SetOperationState(sh SessionHandle, state []byte, encryptKey, authKey ObjectHandle) error {
	e := func() _Ctype_CK_RV{ _cgo0 := /*line :1013:27*/c.ctx; var _cgo1 _Ctype_CK_SESSION_HANDLE = _Ctype_CK_SESSION_HANDLE /*line :1013:53*/(sh); var _cgo2 *_Ctype_CK_BYTE = _Ctype_CK_BYTE_PTR /*line :1013:72*/(unsafe.Pointer(&state[0])); var _cgo3 _Ctype_CK_ULONG = _Ctype_CK_ULONG /*line :1014:13*/(len(state)); var _cgo4 _Ctype_CK_OBJECT_HANDLE = _Ctype_CK_OBJECT_HANDLE /*line :1014:45*/(encryptKey); var _cgo5 _Ctype_CK_OBJECT_HANDLE = _Ctype_CK_OBJECT_HANDLE /*line :1014:77*/(authKey); _cgoCheckPointer(_cgo0, nil); return /*line :1014:87*/_Cfunc_SetOperationState(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5); }()
	return toError(e)
}

// Login logs a user into a token.
func (c *Ctx) Login(sh SessionHandle, userType uint, pin string) error {
	p := ( /*line :1020:7*/_Cfunc_CString /*line :1020:15*/)(pin)
	defer func() func() { _cgo0 := /*line :1021:15*/unsafe.Pointer(p); return func() { _cgoCheckPointer(_cgo0, nil); /*line :1021:33*/_Cfunc_free(_cgo0); }}()()
	e := func() _Ctype_CK_RV{ _cgo0 := /*line :1022:15*/c.ctx; var _cgo1 _Ctype_CK_SESSION_HANDLE = _Ctype_CK_SESSION_HANDLE /*line :1022:41*/(sh); var _cgo2 _Ctype_CK_USER_TYPE = _Ctype_CK_USER_TYPE /*line :1022:61*/(userType); var _cgo3 *_Ctype_char = /*line :1022:73*/p; var _cgo4 _Ctype_CK_ULONG = _Ctype_CK_ULONG /*line :1022:86*/(len(pin)); _cgoCheckPointer(_cgo0, nil); return /*line :1022:97*/_Cfunc_Login(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }()
	return toError(e)
}

// Logout logs a user out from a token.
func (c *Ctx) Logout(sh SessionHandle) error {
	if c.ctx == nil {
		return toError(CKR_CRYPTOKI_NOT_INITIALIZED)
	}
	e := func() _Ctype_CK_RV{ _cgo0 := /*line :1031:16*/c.ctx; var _cgo1 _Ctype_CK_SESSION_HANDLE = _Ctype_CK_SESSION_HANDLE /*line :1031:42*/(sh); _cgoCheckPointer(_cgo0, nil); return /*line :1031:47*/_Cfunc_Logout(_cgo0, _cgo1); }()
	return toError(e)
}

// CreateObject creates a new object.
func (c *Ctx) CreateObject(sh SessionHandle, temp []*Attribute) (ObjectHandle, error) {
	var obj  /*line :1037:10*/_Ctype_CK_OBJECT_HANDLE /*line :1037:28*/
	arena, t, tcount := cAttributeList(temp)
	defer arena.Free()
	e := func() _Ctype_CK_RV{ _cgo0 := /*line :1040:22*/c.ctx; var _cgo1 _Ctype_CK_SESSION_HANDLE = _Ctype_CK_SESSION_HANDLE /*line :1040:48*/(sh); _cgo2 := /*line :1040:54*/t; var _cgo3 _Ctype_CK_ULONG = /*line :1040:57*/tcount; var _cgo4 *_Ctype_CK_OBJECT_HANDLE = _Ctype_CK_OBJECT_HANDLE_PTR /*line :1040:87*/(&obj); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo2, nil); return /*line :1040:94*/_Cfunc_CreateObject(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }()
	e1 := toError(e)
	if e1 == nil {
		return ObjectHandle(obj), nil
	}
	return 0, e1
}

// CopyObject copies an object, creating a new object for the copy.
func (c *Ctx) CopyObject(sh SessionHandle, o ObjectHandle, temp []*Attribute) (ObjectHandle, error) {
	var obj  /*line :1050:10*/_Ctype_CK_OBJECT_HANDLE /*line :1050:28*/
	arena, t, tcount := cAttributeList(temp)
	defer arena.Free()

	e := func() _Ctype_CK_RV{ _cgo0 := /*line :1054:20*/c.ctx; var _cgo1 _Ctype_CK_SESSION_HANDLE = _Ctype_CK_SESSION_HANDLE /*line :1054:46*/(sh); var _cgo2 _Ctype_CK_OBJECT_HANDLE = _Ctype_CK_OBJECT_HANDLE /*line :1054:70*/(o); _cgo3 := /*line :1054:75*/t; var _cgo4 _Ctype_CK_ULONG = /*line :1054:78*/tcount; var _cgo5 *_Ctype_CK_OBJECT_HANDLE = _Ctype_CK_OBJECT_HANDLE_PTR /*line :1054:108*/(&obj); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo3, nil); return /*line :1054:115*/_Cfunc_CopyObject(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5); }()
	e1 := toError(e)
	if e1 == nil {
		return ObjectHandle(obj), nil
	}
	return 0, e1
}

// DestroyObject destroys an object.
func (c *Ctx) DestroyObject(sh SessionHandle, oh ObjectHandle) error {
	e := func() _Ctype_CK_RV{ _cgo0 := /*line :1064:23*/c.ctx; var _cgo1 _Ctype_CK_SESSION_HANDLE = _Ctype_CK_SESSION_HANDLE /*line :1064:49*/(sh); var _cgo2 _Ctype_CK_OBJECT_HANDLE = _Ctype_CK_OBJECT_HANDLE /*line :1064:73*/(oh); _cgoCheckPointer(_cgo0, nil); return /*line :1064:78*/_Cfunc_DestroyObject(_cgo0, _cgo1, _cgo2); }()
	return toError(e)
}

// GetObjectSize gets the size of an object in bytes.
func (c *Ctx) GetObjectSize(sh SessionHandle, oh ObjectHandle) (uint, error) {
	var size  /*line :1070:11*/_Ctype_CK_ULONG /*line :1070:21*/
	e := func() _Ctype_CK_RV{ _cgo0 := /*line :1071:23*/c.ctx; var _cgo1 _Ctype_CK_SESSION_HANDLE = _Ctype_CK_SESSION_HANDLE /*line :1071:49*/(sh); var _cgo2 _Ctype_CK_OBJECT_HANDLE = _Ctype_CK_OBJECT_HANDLE /*line :1071:73*/(oh); var _cgo3 *_Ctype_CK_ULONG = /*line :1071:79*/&size; _cgoCheckPointer(_cgo0, nil); return /*line :1071:85*/_Cfunc_GetObjectSize(_cgo0, _cgo1, _cgo2, _cgo3); }()
	return uint(size), toError(e)
}

// GetAttributeValue obtains the value of one or more object attributes.
func (c *Ctx) GetAttributeValue(sh SessionHandle, o ObjectHandle, a []*Attribute) ([]*Attribute, error) {
	// copy the attribute list and make all the values nil, so that
	// the C function can (allocate) fill them in
	pa := make([] /*line :1079:15*/_Ctype_CK_ATTRIBUTE /*line :1079:29*/, len(a))
	for i := 0; i < len(a); i++ {
		pa[i]._type =  /*line :1081:17*/_Ctype_CK_ATTRIBUTE_TYPE /*line :1081:36*/(a[i].Type)
	}
	e := func() _Ctype_CK_RV{ _cgo0 := /*line :1083:27*/c.ctx; var _cgo1 _Ctype_CK_SESSION_HANDLE = _Ctype_CK_SESSION_HANDLE /*line :1083:53*/(sh); var _cgo2 _Ctype_CK_OBJECT_HANDLE = _Ctype_CK_OBJECT_HANDLE /*line :1083:77*/(o); _cgoIndex3 := &/*line :1083:83*/pa; _cgo3 := /*line :1083:82*/&(*_cgoIndex3)[0]; var _cgo4 _Ctype_CK_ULONG = _Ctype_CK_ULONG /*line :1083:100*/(len(a)); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo3, *_cgoIndex3); return /*line :1083:109*/_Cfunc_GetAttributeValue(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }()
	if err := toError(e); err != nil {
		return nil, err
	}
	a1 := make([]*Attribute, len(a))
	for i, c := range pa {
		x := new(Attribute)
		x.Type = uint(c._type)
		if int(c.ulValueLen) != -1 {
			buf := unsafe.Pointer(func() _Ctype_CK_VOID_PTR{ _cgoBase0 := /*line :1092:45*/&c; _cgo0 := _cgoBase0; _cgoCheckPointer(_cgoBase0, 0 == 0); return /*line :1092:48*/_Cfunc_getAttributePval(_cgo0); }())
			x.Value = func() []byte{ _cgo0 := /*line :1093:24*/buf; var _cgo1 _Ctype_int = _Ctype_int /*line :1093:34*/(c.ulValueLen); _cgoCheckPointer(_cgo0, nil); return /*line :1093:49*/_Cfunc_GoBytes(_cgo0, _cgo1); }()
			func() { _cgo0 := /*line :1094:11*/buf; _cgoCheckPointer(_cgo0, nil); /*line :1094:15*/_Cfunc_free(_cgo0); }()
		}
		a1[i] = x
	}
	return a1, nil
}

// SetAttributeValue modifies the value of one or more object attributes
func (c *Ctx) SetAttributeValue(sh SessionHandle, o ObjectHandle, a []*Attribute) error {
	arena, pa, palen := cAttributeList(a)
	defer arena.Free()
	e := func() _Ctype_CK_RV{ _cgo0 := /*line :1105:27*/c.ctx; var _cgo1 _Ctype_CK_SESSION_HANDLE = _Ctype_CK_SESSION_HANDLE /*line :1105:53*/(sh); var _cgo2 _Ctype_CK_OBJECT_HANDLE = _Ctype_CK_OBJECT_HANDLE /*line :1105:77*/(o); _cgo3 := /*line :1105:82*/pa; var _cgo4 _Ctype_CK_ULONG = /*line :1105:86*/palen; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo3, nil); return /*line :1105:92*/_Cfunc_SetAttributeValue(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }()
	return toError(e)
}

// FindObjectsInit initializes a search for token and session
// objects that match a template.
func (c *Ctx) FindObjectsInit(sh SessionHandle, temp []*Attribute) error {
	arena, t, tcount := cAttributeList(temp)
	defer arena.Free()
	e := func() _Ctype_CK_RV{ _cgo0 := /*line :1114:25*/c.ctx; var _cgo1 _Ctype_CK_SESSION_HANDLE = _Ctype_CK_SESSION_HANDLE /*line :1114:51*/(sh); _cgo2 := /*line :1114:57*/t; var _cgo3 _Ctype_CK_ULONG = /*line :1114:60*/tcount; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo2, nil); return /*line :1114:67*/_Cfunc_FindObjectsInit(_cgo0, _cgo1, _cgo2, _cgo3); }()
	return toError(e)
}

// FindObjects continues a search for token and session
// objects that match a template, obtaining additional object
// handles. Calling the function repeatedly may yield additional results until
// an empty slice is returned.
//
// The returned boolean value is deprecated and should be ignored.
func (c *Ctx) FindObjects(sh SessionHandle, max int) ([]ObjectHandle, bool, error) {
	var (
		objectList  /*line :1126:14*/_Ctype_CK_OBJECT_HANDLE_PTR /*line :1126:36*/
		ulCount     /*line :1127:14*/_Ctype_CK_ULONG /*line :1127:24*/
	)
	e := func() _Ctype_CK_RV{ _cgo0 := /*line :1129:21*/c.ctx; var _cgo1 _Ctype_CK_SESSION_HANDLE = _Ctype_CK_SESSION_HANDLE /*line :1129:47*/(sh); _cgoBase2 := /*line :1129:53*/&objectList; _cgo2 := _cgoBase2; var _cgo3 _Ctype_CK_ULONG = _Ctype_CK_ULONG /*line :1129:76*/(max); var _cgo4 *_Ctype_CK_ULONG = /*line :1129:83*/&ulCount; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase2, 0 == 0); return /*line :1129:92*/_Cfunc_FindObjects(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }()
	if toError(e) != nil {
		return nil, false, toError(e)
	}
	l := toList( /*line :1133:14*/_Ctype_CK_ULONG_PTR /*line :1133:28*/(unsafe.Pointer(objectList)), ulCount)
	// Make again a new list of the correct type.
	// This is copying data, but this is not an often used function.
	o := make([]ObjectHandle, len(l))
	for i, v := range l {
		o[i] = ObjectHandle(v)
	}
	return o, ulCount >  /*line :1140:22*/_Ctype_CK_ULONG /*line :1140:32*/(max), nil
}

// FindObjectsFinal finishes a search for token and session objects.
func (c *Ctx) FindObjectsFinal(sh SessionHandle) error {
	e := func() _Ctype_CK_RV{ _cgo0 := /*line :1145:26*/c.ctx; var _cgo1 _Ctype_CK_SESSION_HANDLE = _Ctype_CK_SESSION_HANDLE /*line :1145:52*/(sh); _cgoCheckPointer(_cgo0, nil); return /*line :1145:57*/_Cfunc_FindObjectsFinal(_cgo0, _cgo1); }()
	return toError(e)
}

// EncryptInit initializes an encryption operation.
func (c *Ctx) EncryptInit(sh SessionHandle, m []*Mechanism, o ObjectHandle) error {
	arena, mech := cMechanism(m)
	defer arena.Free()
	e := func() _Ctype_CK_RV{ _cgo0 := /*line :1153:21*/c.ctx; var _cgo1 _Ctype_CK_SESSION_HANDLE = _Ctype_CK_SESSION_HANDLE /*line :1153:47*/(sh); _cgo2 := /*line :1153:53*/mech; var _cgo3 _Ctype_CK_OBJECT_HANDLE = _Ctype_CK_OBJECT_HANDLE /*line :1153:77*/(o); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo2, nil); return /*line :1153:81*/_Cfunc_EncryptInit(_cgo0, _cgo1, _cgo2, _cgo3); }()
	return toError(e)
}

// Encrypt encrypts single-part data.
func (c *Ctx) Encrypt(sh SessionHandle, message []byte) ([]byte, error) {
	var (
		enc     /*line :1160:10*/_Ctype_CK_BYTE_PTR /*line :1160:23*/
		enclen  /*line :1161:10*/_Ctype_CK_ULONG /*line :1161:20*/
	)
	e := func() _Ctype_CK_RV{ _cgo0 := /*line :1163:17*/c.ctx; var _cgo1 _Ctype_CK_SESSION_HANDLE = _Ctype_CK_SESSION_HANDLE /*line :1163:43*/(sh); var _cgo2 *_Ctype_CK_BYTE = /*line :1163:49*/cMessage(message); var _cgo3 _Ctype_CK_ULONG = _Ctype_CK_ULONG /*line :1163:78*/(len(message)); _cgoBase4 := /*line :1163:94*/&enc; _cgo4 := _cgoBase4; var _cgo5 *_Ctype_CK_ULONG = /*line :1163:100*/&enclen; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase4, 0 == 0); return /*line :1163:108*/_Cfunc_Encrypt(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5); }()
	if toError(e) != nil {
		return nil, toError(e)
	}
	s := func() []byte{ _cgo0 := /*line :1167:17*/unsafe.Pointer(enc); var _cgo1 _Ctype_int = _Ctype_int /*line :1167:43*/(enclen); _cgoCheckPointer(_cgo0, nil); return /*line :1167:52*/_Cfunc_GoBytes(_cgo0, _cgo1); }()
	func() { _cgo0 := /*line :1168:9*/unsafe.Pointer(enc); _cgoCheckPointer(_cgo0, nil); /*line :1168:29*/_Cfunc_free(_cgo0); }()
	return s, nil
}

// EncryptUpdate continues a multiple-part encryption operation.
func (c *Ctx) EncryptUpdate(sh SessionHandle, plain []byte) ([]byte, error) {
	var (
		part     /*line :1175:11*/_Ctype_CK_BYTE_PTR /*line :1175:24*/
		partlen  /*line :1176:11*/_Ctype_CK_ULONG /*line :1176:21*/
	)
	e := func() _Ctype_CK_RV{ _cgo0 := /*line :1178:23*/c.ctx; var _cgo1 _Ctype_CK_SESSION_HANDLE = _Ctype_CK_SESSION_HANDLE /*line :1178:49*/(sh); var _cgo2 *_Ctype_CK_BYTE = /*line :1178:55*/cMessage(plain); var _cgo3 _Ctype_CK_ULONG = _Ctype_CK_ULONG /*line :1178:82*/(len(plain)); _cgoBase4 := /*line :1178:96*/&part; _cgo4 := _cgoBase4; var _cgo5 *_Ctype_CK_ULONG = /*line :1178:103*/&partlen; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase4, 0 == 0); return /*line :1178:112*/_Cfunc_EncryptUpdate(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5); }()
	if toError(e) != nil {
		return nil, toError(e)
	}
	h := func() []byte{ _cgo0 := /*line :1182:17*/unsafe.Pointer(part); var _cgo1 _Ctype_int = _Ctype_int /*line :1182:44*/(partlen); _cgoCheckPointer(_cgo0, nil); return /*line :1182:54*/_Cfunc_GoBytes(_cgo0, _cgo1); }()
	func() { _cgo0 := /*line :1183:9*/unsafe.Pointer(part); _cgoCheckPointer(_cgo0, nil); /*line :1183:30*/_Cfunc_free(_cgo0); }()
	return h, nil
}

// EncryptFinal finishes a multiple-part encryption operation.
func (c *Ctx) EncryptFinal(sh SessionHandle) ([]byte, error) {
	var (
		enc     /*line :1190:10*/_Ctype_CK_BYTE_PTR /*line :1190:23*/
		enclen  /*line :1191:10*/_Ctype_CK_ULONG /*line :1191:20*/
	)
	e := func() _Ctype_CK_RV{ _cgo0 := /*line :1193:22*/c.ctx; var _cgo1 _Ctype_CK_SESSION_HANDLE = _Ctype_CK_SESSION_HANDLE /*line :1193:48*/(sh); _cgoBase2 := /*line :1193:54*/&enc; _cgo2 := _cgoBase2; var _cgo3 *_Ctype_CK_ULONG = /*line :1193:60*/&enclen; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase2, 0 == 0); return /*line :1193:68*/_Cfunc_EncryptFinal(_cgo0, _cgo1, _cgo2, _cgo3); }()
	if toError(e) != nil {
		return nil, toError(e)
	}
	h := func() []byte{ _cgo0 := /*line :1197:17*/unsafe.Pointer(enc); var _cgo1 _Ctype_int = _Ctype_int /*line :1197:43*/(enclen); _cgoCheckPointer(_cgo0, nil); return /*line :1197:52*/_Cfunc_GoBytes(_cgo0, _cgo1); }()
	func() { _cgo0 := /*line :1198:9*/unsafe.Pointer(enc); _cgoCheckPointer(_cgo0, nil); /*line :1198:29*/_Cfunc_free(_cgo0); }()
	return h, nil
}

// DecryptInit initializes a decryption operation.
func (c *Ctx) DecryptInit(sh SessionHandle, m []*Mechanism, o ObjectHandle) error {
	arena, mech := cMechanism(m)
	defer arena.Free()
	e := func() _Ctype_CK_RV{ _cgo0 := /*line :1206:21*/c.ctx; var _cgo1 _Ctype_CK_SESSION_HANDLE = _Ctype_CK_SESSION_HANDLE /*line :1206:47*/(sh); _cgo2 := /*line :1206:53*/mech; var _cgo3 _Ctype_CK_OBJECT_HANDLE = _Ctype_CK_OBJECT_HANDLE /*line :1206:77*/(o); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo2, nil); return /*line :1206:81*/_Cfunc_DecryptInit(_cgo0, _cgo1, _cgo2, _cgo3); }()
	return toError(e)
}

// Decrypt decrypts encrypted data in a single part.
func (c *Ctx) Decrypt(sh SessionHandle, cipher []byte) ([]byte, error) {
	var (
		plain     /*line :1213:12*/_Ctype_CK_BYTE_PTR /*line :1213:25*/
		plainlen  /*line :1214:12*/_Ctype_CK_ULONG /*line :1214:22*/
	)
	e := func() _Ctype_CK_RV{ _cgo0 := /*line :1216:17*/c.ctx; var _cgo1 _Ctype_CK_SESSION_HANDLE = _Ctype_CK_SESSION_HANDLE /*line :1216:43*/(sh); var _cgo2 *_Ctype_CK_BYTE = /*line :1216:49*/cMessage(cipher); var _cgo3 _Ctype_CK_ULONG = _Ctype_CK_ULONG /*line :1216:77*/(len(cipher)); _cgoBase4 := /*line :1216:92*/&plain; _cgo4 := _cgoBase4; var _cgo5 *_Ctype_CK_ULONG = /*line :1216:100*/&plainlen; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase4, 0 == 0); return /*line :1216:110*/_Cfunc_Decrypt(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5); }()
	if toError(e) != nil {
		return nil, toError(e)
	}
	s := func() []byte{ _cgo0 := /*line :1220:17*/unsafe.Pointer(plain); var _cgo1 _Ctype_int = _Ctype_int /*line :1220:45*/(plainlen); _cgoCheckPointer(_cgo0, nil); return /*line :1220:56*/_Cfunc_GoBytes(_cgo0, _cgo1); }()
	func() { _cgo0 := /*line :1221:9*/unsafe.Pointer(plain); _cgoCheckPointer(_cgo0, nil); /*line :1221:31*/_Cfunc_free(_cgo0); }()
	return s, nil
}

// DecryptUpdate continues a multiple-part decryption operation.
func (c *Ctx) DecryptUpdate(sh SessionHandle, cipher []byte) ([]byte, error) {
	var (
		part     /*line :1228:11*/_Ctype_CK_BYTE_PTR /*line :1228:24*/
		partlen  /*line :1229:11*/_Ctype_CK_ULONG /*line :1229:21*/
	)
	e := func() _Ctype_CK_RV{ _cgo0 := /*line :1231:23*/c.ctx; var _cgo1 _Ctype_CK_SESSION_HANDLE = _Ctype_CK_SESSION_HANDLE /*line :1231:49*/(sh); var _cgo2 *_Ctype_CK_BYTE = /*line :1231:55*/cMessage(cipher); var _cgo3 _Ctype_CK_ULONG = _Ctype_CK_ULONG /*line :1231:83*/(len(cipher)); _cgoBase4 := /*line :1231:98*/&part; _cgo4 := _cgoBase4; var _cgo5 *_Ctype_CK_ULONG = /*line :1231:105*/&partlen; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase4, 0 == 0); return /*line :1231:114*/_Cfunc_DecryptUpdate(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5); }()
	if toError(e) != nil {
		return nil, toError(e)
	}
	h := func() []byte{ _cgo0 := /*line :1235:17*/unsafe.Pointer(part); var _cgo1 _Ctype_int = _Ctype_int /*line :1235:44*/(partlen); _cgoCheckPointer(_cgo0, nil); return /*line :1235:54*/_Cfunc_GoBytes(_cgo0, _cgo1); }()
	func() { _cgo0 := /*line :1236:9*/unsafe.Pointer(part); _cgoCheckPointer(_cgo0, nil); /*line :1236:30*/_Cfunc_free(_cgo0); }()
	return h, nil
}

// DecryptFinal finishes a multiple-part decryption operation.
func (c *Ctx) DecryptFinal(sh SessionHandle) ([]byte, error) {
	var (
		plain     /*line :1243:12*/_Ctype_CK_BYTE_PTR /*line :1243:25*/
		plainlen  /*line :1244:12*/_Ctype_CK_ULONG /*line :1244:22*/
	)
	e := func() _Ctype_CK_RV{ _cgo0 := /*line :1246:22*/c.ctx; var _cgo1 _Ctype_CK_SESSION_HANDLE = _Ctype_CK_SESSION_HANDLE /*line :1246:48*/(sh); _cgoBase2 := /*line :1246:54*/&plain; _cgo2 := _cgoBase2; var _cgo3 *_Ctype_CK_ULONG = /*line :1246:62*/&plainlen; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase2, 0 == 0); return /*line :1246:72*/_Cfunc_DecryptFinal(_cgo0, _cgo1, _cgo2, _cgo3); }()
	if toError(e) != nil {
		return nil, toError(e)
	}
	h := func() []byte{ _cgo0 := /*line :1250:17*/unsafe.Pointer(plain); var _cgo1 _Ctype_int = _Ctype_int /*line :1250:45*/(plainlen); _cgoCheckPointer(_cgo0, nil); return /*line :1250:56*/_Cfunc_GoBytes(_cgo0, _cgo1); }()
	func() { _cgo0 := /*line :1251:9*/unsafe.Pointer(plain); _cgoCheckPointer(_cgo0, nil); /*line :1251:31*/_Cfunc_free(_cgo0); }()
	return h, nil
}

// DigestInit initializes a message-digesting operation.
func (c *Ctx) DigestInit(sh SessionHandle, m []*Mechanism) error {
	arena, mech := cMechanism(m)
	defer arena.Free()
	e := func() _Ctype_CK_RV{ _cgo0 := /*line :1259:20*/c.ctx; var _cgo1 _Ctype_CK_SESSION_HANDLE = _Ctype_CK_SESSION_HANDLE /*line :1259:46*/(sh); _cgo2 := /*line :1259:52*/mech; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo2, nil); return /*line :1259:57*/_Cfunc_DigestInit(_cgo0, _cgo1, _cgo2); }()
	return toError(e)
}

// Digest digests message in a single part.
func (c *Ctx) Digest(sh SessionHandle, message []byte) ([]byte, error) {
	var (
		hash     /*line :1266:11*/_Ctype_CK_BYTE_PTR /*line :1266:24*/
		hashlen  /*line :1267:11*/_Ctype_CK_ULONG /*line :1267:21*/
	)
	e := func() _Ctype_CK_RV{ _cgo0 := /*line :1269:16*/c.ctx; var _cgo1 _Ctype_CK_SESSION_HANDLE = _Ctype_CK_SESSION_HANDLE /*line :1269:42*/(sh); var _cgo2 *_Ctype_CK_BYTE = /*line :1269:48*/cMessage(message); var _cgo3 _Ctype_CK_ULONG = _Ctype_CK_ULONG /*line :1269:77*/(len(message)); _cgoBase4 := /*line :1269:93*/&hash; _cgo4 := _cgoBase4; var _cgo5 *_Ctype_CK_ULONG = /*line :1269:100*/&hashlen; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase4, 0 == 0); return /*line :1269:109*/_Cfunc_Digest(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5); }()
	if toError(e) != nil {
		return nil, toError(e)
	}
	h := func() []byte{ _cgo0 := /*line :1273:17*/unsafe.Pointer(hash); var _cgo1 _Ctype_int = _Ctype_int /*line :1273:44*/(hashlen); _cgoCheckPointer(_cgo0, nil); return /*line :1273:54*/_Cfunc_GoBytes(_cgo0, _cgo1); }()
	func() { _cgo0 := /*line :1274:9*/unsafe.Pointer(hash); _cgoCheckPointer(_cgo0, nil); /*line :1274:30*/_Cfunc_free(_cgo0); }()
	return h, nil
}

// DigestUpdate continues a multiple-part message-digesting operation.
func (c *Ctx) DigestUpdate(sh SessionHandle, message []byte) error {
	e := func() _Ctype_CK_RV{ _cgo0 := /*line :1280:22*/c.ctx; var _cgo1 _Ctype_CK_SESSION_HANDLE = _Ctype_CK_SESSION_HANDLE /*line :1280:48*/(sh); var _cgo2 *_Ctype_CK_BYTE = /*line :1280:54*/cMessage(message); var _cgo3 _Ctype_CK_ULONG = _Ctype_CK_ULONG /*line :1280:83*/(len(message)); _cgoCheckPointer(_cgo0, nil); return /*line :1280:98*/_Cfunc_DigestUpdate(_cgo0, _cgo1, _cgo2, _cgo3); }()
	if toError(e) != nil {
		return toError(e)
	}
	return nil
}

// DigestKey continues a multi-part message-digesting
// operation, by digesting the value of a secret key as part of
// the data already digested.
func (c *Ctx) DigestKey(sh SessionHandle, key ObjectHandle) error {
	e := func() _Ctype_CK_RV{ _cgo0 := /*line :1291:19*/c.ctx; var _cgo1 _Ctype_CK_SESSION_HANDLE = _Ctype_CK_SESSION_HANDLE /*line :1291:45*/(sh); var _cgo2 _Ctype_CK_OBJECT_HANDLE = _Ctype_CK_OBJECT_HANDLE /*line :1291:69*/(key); _cgoCheckPointer(_cgo0, nil); return /*line :1291:75*/_Cfunc_DigestKey(_cgo0, _cgo1, _cgo2); }()
	if toError(e) != nil {
		return toError(e)
	}
	return nil
}

// DigestFinal finishes a multiple-part message-digesting operation.
func (c *Ctx) DigestFinal(sh SessionHandle) ([]byte, error) {
	var (
		hash     /*line :1301:11*/_Ctype_CK_BYTE_PTR /*line :1301:24*/
		hashlen  /*line :1302:11*/_Ctype_CK_ULONG /*line :1302:21*/
	)
	e := func() _Ctype_CK_RV{ _cgo0 := /*line :1304:21*/c.ctx; var _cgo1 _Ctype_CK_SESSION_HANDLE = _Ctype_CK_SESSION_HANDLE /*line :1304:47*/(sh); _cgoBase2 := /*line :1304:53*/&hash; _cgo2 := _cgoBase2; var _cgo3 *_Ctype_CK_ULONG = /*line :1304:60*/&hashlen; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase2, 0 == 0); return /*line :1304:69*/_Cfunc_DigestFinal(_cgo0, _cgo1, _cgo2, _cgo3); }()
	if toError(e) != nil {
		return nil, toError(e)
	}
	h := func() []byte{ _cgo0 := /*line :1308:17*/unsafe.Pointer(hash); var _cgo1 _Ctype_int = _Ctype_int /*line :1308:44*/(hashlen); _cgoCheckPointer(_cgo0, nil); return /*line :1308:54*/_Cfunc_GoBytes(_cgo0, _cgo1); }()
	func() { _cgo0 := /*line :1309:9*/unsafe.Pointer(hash); _cgoCheckPointer(_cgo0, nil); /*line :1309:30*/_Cfunc_free(_cgo0); }()
	return h, nil
}

// SignInit initializes a signature (private key encryption)
// operation, where the signature is (will be) an appendix to
// the data, and plaintext cannot be recovered from the signature.
func (c *Ctx) SignInit(sh SessionHandle, m []*Mechanism, o ObjectHandle) error {
	arena, mech := cMechanism(m)
	defer arena.Free()
	e := func() _Ctype_CK_RV{ _cgo0 := /*line :1319:18*/c.ctx; var _cgo1 _Ctype_CK_SESSION_HANDLE = _Ctype_CK_SESSION_HANDLE /*line :1319:44*/(sh); _cgo2 := /*line :1319:50*/mech; var _cgo3 _Ctype_CK_OBJECT_HANDLE = _Ctype_CK_OBJECT_HANDLE /*line :1319:74*/(o); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo2, nil); return /*line :1319:78*/_Cfunc_SignInit(_cgo0, _cgo1, _cgo2, _cgo3); }()
	return toError(e)
}

// Sign signs (encrypts with private key) data in a single part, where the signature
// is (will be) an appendix to the data, and plaintext cannot be recovered from the signature.
func (c *Ctx) Sign(sh SessionHandle, message []byte) ([]byte, error) {
	var (
		sig     /*line :1327:10*/_Ctype_CK_BYTE_PTR /*line :1327:23*/
		siglen  /*line :1328:10*/_Ctype_CK_ULONG /*line :1328:20*/
	)
	e := func() _Ctype_CK_RV{ _cgo0 := /*line :1330:14*/c.ctx; var _cgo1 _Ctype_CK_SESSION_HANDLE = _Ctype_CK_SESSION_HANDLE /*line :1330:40*/(sh); var _cgo2 *_Ctype_CK_BYTE = /*line :1330:46*/cMessage(message); var _cgo3 _Ctype_CK_ULONG = _Ctype_CK_ULONG /*line :1330:75*/(len(message)); _cgoBase4 := /*line :1330:91*/&sig; _cgo4 := _cgoBase4; var _cgo5 *_Ctype_CK_ULONG = /*line :1330:97*/&siglen; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase4, 0 == 0); return /*line :1330:105*/_Cfunc_Sign(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5); }()
	if toError(e) != nil {
		return nil, toError(e)
	}
	s := func() []byte{ _cgo0 := /*line :1334:17*/unsafe.Pointer(sig); var _cgo1 _Ctype_int = _Ctype_int /*line :1334:43*/(siglen); _cgoCheckPointer(_cgo0, nil); return /*line :1334:52*/_Cfunc_GoBytes(_cgo0, _cgo1); }()
	func() { _cgo0 := /*line :1335:9*/unsafe.Pointer(sig); _cgoCheckPointer(_cgo0, nil); /*line :1335:29*/_Cfunc_free(_cgo0); }()
	return s, nil
}

// SignUpdate continues a multiple-part signature operation,
// where the signature is (will be) an appendix to the data,
// and plaintext cannot be recovered from the signature.
func (c *Ctx) SignUpdate(sh SessionHandle, message []byte) error {
	e := func() _Ctype_CK_RV{ _cgo0 := /*line :1343:20*/c.ctx; var _cgo1 _Ctype_CK_SESSION_HANDLE = _Ctype_CK_SESSION_HANDLE /*line :1343:46*/(sh); var _cgo2 *_Ctype_CK_BYTE = /*line :1343:52*/cMessage(message); var _cgo3 _Ctype_CK_ULONG = _Ctype_CK_ULONG /*line :1343:81*/(len(message)); _cgoCheckPointer(_cgo0, nil); return /*line :1343:96*/_Cfunc_SignUpdate(_cgo0, _cgo1, _cgo2, _cgo3); }()
	return toError(e)
}

// SignFinal finishes a multiple-part signature operation returning the signature.
func (c *Ctx) SignFinal(sh SessionHandle) ([]byte, error) {
	var (
		sig     /*line :1350:10*/_Ctype_CK_BYTE_PTR /*line :1350:23*/
		siglen  /*line :1351:10*/_Ctype_CK_ULONG /*line :1351:20*/
	)
	e := func() _Ctype_CK_RV{ _cgo0 := /*line :1353:19*/c.ctx; var _cgo1 _Ctype_CK_SESSION_HANDLE = _Ctype_CK_SESSION_HANDLE /*line :1353:45*/(sh); _cgoBase2 := /*line :1353:51*/&sig; _cgo2 := _cgoBase2; var _cgo3 *_Ctype_CK_ULONG = /*line :1353:57*/&siglen; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase2, 0 == 0); return /*line :1353:65*/_Cfunc_SignFinal(_cgo0, _cgo1, _cgo2, _cgo3); }()
	if toError(e) != nil {
		return nil, toError(e)
	}
	h := func() []byte{ _cgo0 := /*line :1357:17*/unsafe.Pointer(sig); var _cgo1 _Ctype_int = _Ctype_int /*line :1357:43*/(siglen); _cgoCheckPointer(_cgo0, nil); return /*line :1357:52*/_Cfunc_GoBytes(_cgo0, _cgo1); }()
	func() { _cgo0 := /*line :1358:9*/unsafe.Pointer(sig); _cgoCheckPointer(_cgo0, nil); /*line :1358:29*/_Cfunc_free(_cgo0); }()
	return h, nil
}

// SignRecoverInit initializes a signature operation, where the data can be recovered from the signature.
func (c *Ctx) SignRecoverInit(sh SessionHandle, m []*Mechanism, key ObjectHandle) error {
	arena, mech := cMechanism(m)
	defer arena.Free()
	e := func() _Ctype_CK_RV{ _cgo0 := /*line :1366:25*/c.ctx; var _cgo1 _Ctype_CK_SESSION_HANDLE = _Ctype_CK_SESSION_HANDLE /*line :1366:51*/(sh); _cgo2 := /*line :1366:57*/mech; var _cgo3 _Ctype_CK_OBJECT_HANDLE = _Ctype_CK_OBJECT_HANDLE /*line :1366:81*/(key); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo2, nil); return /*line :1366:87*/_Cfunc_SignRecoverInit(_cgo0, _cgo1, _cgo2, _cgo3); }()
	return toError(e)
}

// SignRecover signs data in a single operation, where the data can be recovered from the signature.
func (c *Ctx) SignRecover(sh SessionHandle, data []byte) ([]byte, error) {
	var (
		sig     /*line :1373:10*/_Ctype_CK_BYTE_PTR /*line :1373:23*/
		siglen  /*line :1374:10*/_Ctype_CK_ULONG /*line :1374:20*/
	)
	e := func() _Ctype_CK_RV{ _cgo0 := /*line :1376:21*/c.ctx; var _cgo1 _Ctype_CK_SESSION_HANDLE = _Ctype_CK_SESSION_HANDLE /*line :1376:47*/(sh); var _cgo2 *_Ctype_CK_BYTE = /*line :1376:53*/cMessage(data); var _cgo3 _Ctype_CK_ULONG = _Ctype_CK_ULONG /*line :1376:79*/(len(data)); _cgoBase4 := /*line :1376:92*/&sig; _cgo4 := _cgoBase4; var _cgo5 *_Ctype_CK_ULONG = /*line :1376:98*/&siglen; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase4, 0 == 0); return /*line :1376:106*/_Cfunc_SignRecover(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5); }()
	if toError(e) != nil {
		return nil, toError(e)
	}
	h := func() []byte{ _cgo0 := /*line :1380:17*/unsafe.Pointer(sig); var _cgo1 _Ctype_int = _Ctype_int /*line :1380:43*/(siglen); _cgoCheckPointer(_cgo0, nil); return /*line :1380:52*/_Cfunc_GoBytes(_cgo0, _cgo1); }()
	func() { _cgo0 := /*line :1381:9*/unsafe.Pointer(sig); _cgoCheckPointer(_cgo0, nil); /*line :1381:29*/_Cfunc_free(_cgo0); }()
	return h, nil
}

// VerifyInit initializes a verification operation, where the
// signature is an appendix to the data, and plaintext cannot
// be recovered from the signature (e.g. DSA).
func (c *Ctx) VerifyInit(sh SessionHandle, m []*Mechanism, key ObjectHandle) error {
	arena, mech := cMechanism(m)
	defer arena.Free()
	e := func() _Ctype_CK_RV{ _cgo0 := /*line :1391:20*/c.ctx; var _cgo1 _Ctype_CK_SESSION_HANDLE = _Ctype_CK_SESSION_HANDLE /*line :1391:46*/(sh); _cgo2 := /*line :1391:52*/mech; var _cgo3 _Ctype_CK_OBJECT_HANDLE = _Ctype_CK_OBJECT_HANDLE /*line :1391:76*/(key); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo2, nil); return /*line :1391:82*/_Cfunc_VerifyInit(_cgo0, _cgo1, _cgo2, _cgo3); }()
	return toError(e)
}

// Verify verifies a signature in a single-part operation,
// where the signature is an appendix to the data, and plaintext
// cannot be recovered from the signature.
func (c *Ctx) Verify(sh SessionHandle, data []byte, signature []byte) error {
	e := func() _Ctype_CK_RV{ _cgo0 := /*line :1399:16*/c.ctx; var _cgo1 _Ctype_CK_SESSION_HANDLE = _Ctype_CK_SESSION_HANDLE /*line :1399:42*/(sh); var _cgo2 *_Ctype_CK_BYTE = /*line :1399:48*/cMessage(data); var _cgo3 _Ctype_CK_ULONG = _Ctype_CK_ULONG /*line :1399:74*/(len(data)); var _cgo4 *_Ctype_CK_BYTE = /*line :1399:87*/cMessage(signature); var _cgo5 _Ctype_CK_ULONG = _Ctype_CK_ULONG /*line :1399:118*/(len(signature)); _cgoCheckPointer(_cgo0, nil); return /*line :1399:135*/_Cfunc_Verify(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5); }()
	return toError(e)
}

// VerifyUpdate continues a multiple-part verification
// operation, where the signature is an appendix to the data,
// and plaintext cannot be recovered from the signature.
func (c *Ctx) VerifyUpdate(sh SessionHandle, part []byte) error {
	e := func() _Ctype_CK_RV{ _cgo0 := /*line :1407:22*/c.ctx; var _cgo1 _Ctype_CK_SESSION_HANDLE = _Ctype_CK_SESSION_HANDLE /*line :1407:48*/(sh); var _cgo2 *_Ctype_CK_BYTE = /*line :1407:54*/cMessage(part); var _cgo3 _Ctype_CK_ULONG = _Ctype_CK_ULONG /*line :1407:80*/(len(part)); _cgoCheckPointer(_cgo0, nil); return /*line :1407:92*/_Cfunc_VerifyUpdate(_cgo0, _cgo1, _cgo2, _cgo3); }()
	return toError(e)
}

// VerifyFinal finishes a multiple-part verification
// operation, checking the signature.
func (c *Ctx) VerifyFinal(sh SessionHandle, signature []byte) error {
	e := func() _Ctype_CK_RV{ _cgo0 := /*line :1414:21*/c.ctx; var _cgo1 _Ctype_CK_SESSION_HANDLE = _Ctype_CK_SESSION_HANDLE /*line :1414:47*/(sh); var _cgo2 *_Ctype_CK_BYTE = /*line :1414:53*/cMessage(signature); var _cgo3 _Ctype_CK_ULONG = _Ctype_CK_ULONG /*line :1414:84*/(len(signature)); _cgoCheckPointer(_cgo0, nil); return /*line :1414:101*/_Cfunc_VerifyFinal(_cgo0, _cgo1, _cgo2, _cgo3); }()
	return toError(e)
}

// VerifyRecoverInit initializes a signature verification
// operation, where the data is recovered from the signature.
func (c *Ctx) VerifyRecoverInit(sh SessionHandle, m []*Mechanism, key ObjectHandle) error {
	arena, mech := cMechanism(m)
	defer arena.Free()
	e := func() _Ctype_CK_RV{ _cgo0 := /*line :1423:27*/c.ctx; var _cgo1 _Ctype_CK_SESSION_HANDLE = _Ctype_CK_SESSION_HANDLE /*line :1423:53*/(sh); _cgo2 := /*line :1423:59*/mech; var _cgo3 _Ctype_CK_OBJECT_HANDLE = _Ctype_CK_OBJECT_HANDLE /*line :1423:83*/(key); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo2, nil); return /*line :1423:89*/_Cfunc_VerifyRecoverInit(_cgo0, _cgo1, _cgo2, _cgo3); }()
	return toError(e)
}

// VerifyRecover verifies a signature in a single-part
// operation, where the data is recovered from the signature.
func (c *Ctx) VerifyRecover(sh SessionHandle, signature []byte) ([]byte, error) {
	var (
		data     /*line :1431:11*/_Ctype_CK_BYTE_PTR /*line :1431:24*/
		datalen  /*line :1432:11*/_Ctype_CK_ULONG /*line :1432:21*/
	)
	e := func() _Ctype_CK_RV{ _cgo0 := /*line :1434:29*/c.ctx; var _cgo1 _Ctype_CK_SESSION_HANDLE = _Ctype_CK_SESSION_HANDLE /*line :1434:55*/(sh); var _cgo2 *_Ctype_CK_BYTE = /*line :1434:61*/cMessage(signature); var _cgo3 _Ctype_CK_ULONG = _Ctype_CK_ULONG /*line :1434:92*/(len(signature)); _cgoBase4 := /*line :1434:110*/&data; _cgo4 := _cgoBase4; var _cgo5 *_Ctype_CK_ULONG = /*line :1434:117*/&datalen; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase4, 0 == 0); return /*line :1434:126*/_Cfunc_DecryptVerifyUpdate(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5); }()
	if toError(e) != nil {
		return nil, toError(e)
	}
	h := func() []byte{ _cgo0 := /*line :1438:17*/unsafe.Pointer(data); var _cgo1 _Ctype_int = _Ctype_int /*line :1438:44*/(datalen); _cgoCheckPointer(_cgo0, nil); return /*line :1438:54*/_Cfunc_GoBytes(_cgo0, _cgo1); }()
	func() { _cgo0 := /*line :1439:9*/unsafe.Pointer(data); _cgoCheckPointer(_cgo0, nil); /*line :1439:30*/_Cfunc_free(_cgo0); }()
	return h, nil
}

// DigestEncryptUpdate continues a multiple-part digesting and encryption operation.
func (c *Ctx) DigestEncryptUpdate(sh SessionHandle, part []byte) ([]byte, error) {
	var (
		enc     /*line :1446:10*/_Ctype_CK_BYTE_PTR /*line :1446:23*/
		enclen  /*line :1447:10*/_Ctype_CK_ULONG /*line :1447:20*/
	)
	e := func() _Ctype_CK_RV{ _cgo0 := /*line :1449:29*/c.ctx; var _cgo1 _Ctype_CK_SESSION_HANDLE = _Ctype_CK_SESSION_HANDLE /*line :1449:55*/(sh); var _cgo2 *_Ctype_CK_BYTE = /*line :1449:61*/cMessage(part); var _cgo3 _Ctype_CK_ULONG = _Ctype_CK_ULONG /*line :1449:87*/(len(part)); _cgoBase4 := /*line :1449:100*/&enc; _cgo4 := _cgoBase4; var _cgo5 *_Ctype_CK_ULONG = /*line :1449:106*/&enclen; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase4, 0 == 0); return /*line :1449:114*/_Cfunc_DigestEncryptUpdate(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5); }()
	if toError(e) != nil {
		return nil, toError(e)
	}
	h := func() []byte{ _cgo0 := /*line :1453:17*/unsafe.Pointer(enc); var _cgo1 _Ctype_int = _Ctype_int /*line :1453:43*/(enclen); _cgoCheckPointer(_cgo0, nil); return /*line :1453:52*/_Cfunc_GoBytes(_cgo0, _cgo1); }()
	func() { _cgo0 := /*line :1454:9*/unsafe.Pointer(enc); _cgoCheckPointer(_cgo0, nil); /*line :1454:29*/_Cfunc_free(_cgo0); }()
	return h, nil
}

// DecryptDigestUpdate continues a multiple-part decryption and digesting operation.
func (c *Ctx) DecryptDigestUpdate(sh SessionHandle, cipher []byte) ([]byte, error) {
	var (
		part     /*line :1461:11*/_Ctype_CK_BYTE_PTR /*line :1461:24*/
		partlen  /*line :1462:11*/_Ctype_CK_ULONG /*line :1462:21*/
	)
	e := func() _Ctype_CK_RV{ _cgo0 := /*line :1464:29*/c.ctx; var _cgo1 _Ctype_CK_SESSION_HANDLE = _Ctype_CK_SESSION_HANDLE /*line :1464:55*/(sh); var _cgo2 *_Ctype_CK_BYTE = /*line :1464:61*/cMessage(cipher); var _cgo3 _Ctype_CK_ULONG = _Ctype_CK_ULONG /*line :1464:89*/(len(cipher)); _cgoBase4 := /*line :1464:104*/&part; _cgo4 := _cgoBase4; var _cgo5 *_Ctype_CK_ULONG = /*line :1464:111*/&partlen; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase4, 0 == 0); return /*line :1464:120*/_Cfunc_DecryptDigestUpdate(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5); }()
	if toError(e) != nil {
		return nil, toError(e)
	}
	h := func() []byte{ _cgo0 := /*line :1468:17*/unsafe.Pointer(part); var _cgo1 _Ctype_int = _Ctype_int /*line :1468:44*/(partlen); _cgoCheckPointer(_cgo0, nil); return /*line :1468:54*/_Cfunc_GoBytes(_cgo0, _cgo1); }()
	func() { _cgo0 := /*line :1469:9*/unsafe.Pointer(part); _cgoCheckPointer(_cgo0, nil); /*line :1469:30*/_Cfunc_free(_cgo0); }()
	return h, nil
}

// SignEncryptUpdate continues a multiple-part signing and encryption operation.
func (c *Ctx) SignEncryptUpdate(sh SessionHandle, part []byte) ([]byte, error) {
	var (
		enc     /*line :1476:10*/_Ctype_CK_BYTE_PTR /*line :1476:23*/
		enclen  /*line :1477:10*/_Ctype_CK_ULONG /*line :1477:20*/
	)
	e := func() _Ctype_CK_RV{ _cgo0 := /*line :1479:27*/c.ctx; var _cgo1 _Ctype_CK_SESSION_HANDLE = _Ctype_CK_SESSION_HANDLE /*line :1479:53*/(sh); var _cgo2 *_Ctype_CK_BYTE = /*line :1479:59*/cMessage(part); var _cgo3 _Ctype_CK_ULONG = _Ctype_CK_ULONG /*line :1479:85*/(len(part)); _cgoBase4 := /*line :1479:98*/&enc; _cgo4 := _cgoBase4; var _cgo5 *_Ctype_CK_ULONG = /*line :1479:104*/&enclen; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase4, 0 == 0); return /*line :1479:112*/_Cfunc_SignEncryptUpdate(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5); }()
	if toError(e) != nil {
		return nil, toError(e)
	}
	h := func() []byte{ _cgo0 := /*line :1483:17*/unsafe.Pointer(enc); var _cgo1 _Ctype_int = _Ctype_int /*line :1483:43*/(enclen); _cgoCheckPointer(_cgo0, nil); return /*line :1483:52*/_Cfunc_GoBytes(_cgo0, _cgo1); }()
	func() { _cgo0 := /*line :1484:9*/unsafe.Pointer(enc); _cgoCheckPointer(_cgo0, nil); /*line :1484:29*/_Cfunc_free(_cgo0); }()
	return h, nil
}

// DecryptVerifyUpdate continues a multiple-part decryption and verify operation.
func (c *Ctx) DecryptVerifyUpdate(sh SessionHandle, cipher []byte) ([]byte, error) {
	var (
		part     /*line :1491:11*/_Ctype_CK_BYTE_PTR /*line :1491:24*/
		partlen  /*line :1492:11*/_Ctype_CK_ULONG /*line :1492:21*/
	)
	e := func() _Ctype_CK_RV{ _cgo0 := /*line :1494:29*/c.ctx; var _cgo1 _Ctype_CK_SESSION_HANDLE = _Ctype_CK_SESSION_HANDLE /*line :1494:55*/(sh); var _cgo2 *_Ctype_CK_BYTE = /*line :1494:61*/cMessage(cipher); var _cgo3 _Ctype_CK_ULONG = _Ctype_CK_ULONG /*line :1494:89*/(len(cipher)); _cgoBase4 := /*line :1494:104*/&part; _cgo4 := _cgoBase4; var _cgo5 *_Ctype_CK_ULONG = /*line :1494:111*/&partlen; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase4, 0 == 0); return /*line :1494:120*/_Cfunc_DecryptVerifyUpdate(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5); }()
	if toError(e) != nil {
		return nil, toError(e)
	}
	h := func() []byte{ _cgo0 := /*line :1498:17*/unsafe.Pointer(part); var _cgo1 _Ctype_int = _Ctype_int /*line :1498:44*/(partlen); _cgoCheckPointer(_cgo0, nil); return /*line :1498:54*/_Cfunc_GoBytes(_cgo0, _cgo1); }()
	func() { _cgo0 := /*line :1499:9*/unsafe.Pointer(part); _cgoCheckPointer(_cgo0, nil); /*line :1499:30*/_Cfunc_free(_cgo0); }()
	return h, nil
}

// GenerateKey generates a secret key, creating a new key object.
func (c *Ctx) GenerateKey(sh SessionHandle, m []*Mechanism, temp []*Attribute) (ObjectHandle, error) {
	var key  /*line :1505:10*/_Ctype_CK_OBJECT_HANDLE /*line :1505:28*/
	attrarena, t, tcount := cAttributeList(temp)
	defer attrarena.Free()
	mecharena, mech := cMechanism(m)
	defer mecharena.Free()
	e := func() _Ctype_CK_RV{ _cgo0 := /*line :1510:21*/c.ctx; var _cgo1 _Ctype_CK_SESSION_HANDLE = _Ctype_CK_SESSION_HANDLE /*line :1510:47*/(sh); _cgo2 := /*line :1510:53*/mech; _cgo3 := /*line :1510:59*/t; var _cgo4 _Ctype_CK_ULONG = /*line :1510:62*/tcount; var _cgo5 *_Ctype_CK_OBJECT_HANDLE = _Ctype_CK_OBJECT_HANDLE_PTR /*line :1510:92*/(&key); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo2, nil); _cgoCheckPointer(_cgo3, nil); return /*line :1510:99*/_Cfunc_GenerateKey(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5); }()
	e1 := toError(e)
	if e1 == nil {
		return ObjectHandle(key), nil
	}
	return 0, e1
}

// GenerateKeyPair generates a public-key/private-key pair creating new key objects.
func (c *Ctx) GenerateKeyPair(sh SessionHandle, m []*Mechanism, public, private []*Attribute) (ObjectHandle, ObjectHandle, error) {
	var (
		pubkey   /*line :1521:11*/_Ctype_CK_OBJECT_HANDLE /*line :1521:29*/
		privkey  /*line :1522:11*/_Ctype_CK_OBJECT_HANDLE /*line :1522:29*/
	)
	pubarena, pub, pubcount := cAttributeList(public)
	defer pubarena.Free()
	privarena, priv, privcount := cAttributeList(private)
	defer privarena.Free()
	mecharena, mech := cMechanism(m)
	defer mecharena.Free()
	e := func() _Ctype_CK_RV{ _cgo0 := /*line :1530:25*/c.ctx; var _cgo1 _Ctype_CK_SESSION_HANDLE = _Ctype_CK_SESSION_HANDLE /*line :1530:51*/(sh); _cgo2 := /*line :1530:57*/mech; _cgo3 := /*line :1530:63*/pub; var _cgo4 _Ctype_CK_ULONG = /*line :1530:68*/pubcount; _cgo5 := /*line :1530:78*/priv; var _cgo6 _Ctype_CK_ULONG = /*line :1530:84*/privcount; var _cgo7 *_Ctype_CK_OBJECT_HANDLE = _Ctype_CK_OBJECT_HANDLE_PTR /*line :1530:117*/(&pubkey); var _cgo8 *_Ctype_CK_OBJECT_HANDLE = _Ctype_CK_OBJECT_HANDLE_PTR /*line :1530:150*/(&privkey); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo2, nil); _cgoCheckPointer(_cgo3, nil); _cgoCheckPointer(_cgo5, nil); return /*line :1530:161*/_Cfunc_GenerateKeyPair(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5, _cgo6, _cgo7, _cgo8); }()
	e1 := toError(e)
	if e1 == nil {
		return ObjectHandle(pubkey), ObjectHandle(privkey), nil
	}
	return 0, 0, e1
}

// WrapKey wraps (i.e., encrypts) a key.
func (c *Ctx) WrapKey(sh SessionHandle, m []*Mechanism, wrappingkey, key ObjectHandle) ([]byte, error) {
	var (
		wrappedkey     /*line :1541:17*/_Ctype_CK_BYTE_PTR /*line :1541:30*/
		wrappedkeylen  /*line :1542:17*/_Ctype_CK_ULONG /*line :1542:27*/
	)
	arena, mech := cMechanism(m)
	defer arena.Free()
	e := func() _Ctype_CK_RV{ _cgo0 := /*line :1546:17*/c.ctx; var _cgo1 _Ctype_CK_SESSION_HANDLE = _Ctype_CK_SESSION_HANDLE /*line :1546:43*/(sh); _cgo2 := /*line :1546:49*/mech; var _cgo3 _Ctype_CK_OBJECT_HANDLE = _Ctype_CK_OBJECT_HANDLE /*line :1546:73*/(wrappingkey); var _cgo4 _Ctype_CK_OBJECT_HANDLE = _Ctype_CK_OBJECT_HANDLE /*line :1546:106*/(key); _cgoBase5 := /*line :1546:113*/&wrappedkey; _cgo5 := _cgoBase5; var _cgo6 *_Ctype_CK_ULONG = /*line :1546:126*/&wrappedkeylen; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo2, nil); _cgoCheckPointer(_cgoBase5, 0 == 0); return /*line :1546:141*/_Cfunc_WrapKey(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5, _cgo6); }()
	if toError(e) != nil {
		return nil, toError(e)
	}
	h := func() []byte{ _cgo0 := /*line :1550:17*/unsafe.Pointer(wrappedkey); var _cgo1 _Ctype_int = _Ctype_int /*line :1550:50*/(wrappedkeylen); _cgoCheckPointer(_cgo0, nil); return /*line :1550:66*/_Cfunc_GoBytes(_cgo0, _cgo1); }()
	func() { _cgo0 := /*line :1551:9*/unsafe.Pointer(wrappedkey); _cgoCheckPointer(_cgo0, nil); /*line :1551:36*/_Cfunc_free(_cgo0); }()
	return h, nil
}

// UnwrapKey unwraps (decrypts) a wrapped key, creating a new key object.
func (c *Ctx) UnwrapKey(sh SessionHandle, m []*Mechanism, unwrappingkey ObjectHandle, wrappedkey []byte, a []*Attribute) (ObjectHandle, error) {
	var key  /*line :1557:10*/_Ctype_CK_OBJECT_HANDLE /*line :1557:28*/
	attrarena, ac, aclen := cAttributeList(a)
	defer attrarena.Free()
	mecharena, mech := cMechanism(m)
	defer mecharena.Free()
	e := func() _Ctype_CK_RV{ _cgo0 := /*line :1562:19*/c.ctx; var _cgo1 _Ctype_CK_SESSION_HANDLE = _Ctype_CK_SESSION_HANDLE /*line :1562:45*/(sh); _cgo2 := /*line :1562:51*/mech; var _cgo3 _Ctype_CK_OBJECT_HANDLE = _Ctype_CK_OBJECT_HANDLE /*line :1562:75*/(unwrappingkey); var _cgo4 *_Ctype_CK_BYTE = _Ctype_CK_BYTE_PTR /*line :1562:105*/(unsafe.Pointer(&wrappedkey[0])); var _cgo5 _Ctype_CK_ULONG = _Ctype_CK_ULONG /*line :1562:149*/(len(wrappedkey)); _cgo6 := /*line :1562:168*/ac; var _cgo7 _Ctype_CK_ULONG = /*line :1562:172*/aclen; var _cgo8 *_Ctype_CK_OBJECT_HANDLE = /*line :1562:179*/&key; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo2, nil); _cgoCheckPointer(_cgo6, nil); return /*line :1562:184*/_Cfunc_UnwrapKey(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5, _cgo6, _cgo7, _cgo8); }()
	return ObjectHandle(key), toError(e)
}

// DeriveKey derives a key from a base key, creating a new key object.
func (c *Ctx) DeriveKey(sh SessionHandle, m []*Mechanism, basekey ObjectHandle, a []*Attribute) (ObjectHandle, error) {
	var key  /*line :1568:10*/_Ctype_CK_OBJECT_HANDLE /*line :1568:28*/
	attrarena, ac, aclen := cAttributeList(a)
	defer attrarena.Free()
	mecharena, mech := cMechanism(m)
	defer mecharena.Free()
	e := func() _Ctype_CK_RV{ _cgo0 := /*line :1573:19*/c.ctx; var _cgo1 _Ctype_CK_SESSION_HANDLE = _Ctype_CK_SESSION_HANDLE /*line :1573:45*/(sh); _cgo2 := /*line :1573:51*/mech; var _cgo3 _Ctype_CK_OBJECT_HANDLE = _Ctype_CK_OBJECT_HANDLE /*line :1573:75*/(basekey); _cgo4 := /*line :1573:86*/ac; var _cgo5 _Ctype_CK_ULONG = /*line :1573:90*/aclen; var _cgo6 *_Ctype_CK_OBJECT_HANDLE = /*line :1573:97*/&key; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo2, nil); _cgoCheckPointer(_cgo4, nil); return /*line :1573:102*/_Cfunc_DeriveKey(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5, _cgo6); }()
	return ObjectHandle(key), toError(e)
}

// SeedRandom mixes additional seed material into the token's
// random number generator.
func (c *Ctx) SeedRandom(sh SessionHandle, seed []byte) error {
	e := func() _Ctype_CK_RV{ _cgo0 := /*line :1580:20*/c.ctx; var _cgo1 _Ctype_CK_SESSION_HANDLE = _Ctype_CK_SESSION_HANDLE /*line :1580:46*/(sh); var _cgo2 *_Ctype_CK_BYTE = _Ctype_CK_BYTE_PTR /*line :1580:65*/(unsafe.Pointer(&seed[0])); var _cgo3 _Ctype_CK_ULONG = _Ctype_CK_ULONG /*line :1580:103*/(len(seed)); _cgoCheckPointer(_cgo0, nil); return /*line :1580:115*/_Cfunc_SeedRandom(_cgo0, _cgo1, _cgo2, _cgo3); }()
	return toError(e)
}

// GenerateRandom generates random data.
func (c *Ctx) GenerateRandom(sh SessionHandle, length int) ([]byte, error) {
	var rand  /*line :1586:11*/_Ctype_CK_BYTE_PTR /*line :1586:24*/
	e := func() _Ctype_CK_RV{ _cgo0 := /*line :1587:24*/c.ctx; var _cgo1 _Ctype_CK_SESSION_HANDLE = _Ctype_CK_SESSION_HANDLE /*line :1587:50*/(sh); _cgoBase2 := /*line :1587:56*/&rand; _cgo2 := _cgoBase2; var _cgo3 _Ctype_CK_ULONG = _Ctype_CK_ULONG /*line :1587:73*/(length); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase2, 0 == 0); return /*line :1587:82*/_Cfunc_GenerateRandom(_cgo0, _cgo1, _cgo2, _cgo3); }()
	if toError(e) != nil {
		return nil, toError(e)
	}
	h := func() []byte{ _cgo0 := /*line :1591:17*/unsafe.Pointer(rand); var _cgo1 _Ctype_int = _Ctype_int /*line :1591:44*/(length); _cgoCheckPointer(_cgo0, nil); return /*line :1591:53*/_Cfunc_GoBytes(_cgo0, _cgo1); }()
	func() { _cgo0 := /*line :1592:9*/unsafe.Pointer(rand); _cgoCheckPointer(_cgo0, nil); /*line :1592:30*/_Cfunc_free(_cgo0); }()
	return h, nil
}

// WaitForSlotEvent returns a channel which returns a slot event
// (token insertion, removal, etc.) when it occurs.
func (c *Ctx) WaitForSlotEvent(flags uint) chan SlotEvent {
	sl := make(chan SlotEvent, 1) // hold one element
	go c.waitForSlotEventHelper(flags, sl)
	return sl
}

func (c *Ctx) waitForSlotEventHelper(f uint, sl chan SlotEvent) {
	var slotID  /*line :1605:13*/_Ctype_CK_ULONG /*line :1605:23*/
	func() _Ctype_CK_RV{ _cgo0 := /*line :1606:21*/c.ctx; var _cgo1 _Ctype_CK_FLAGS = _Ctype_CK_FLAGS /*line :1606:38*/(f); var _cgo2 *_Ctype_CK_ULONG = /*line :1606:43*/&slotID; _cgoCheckPointer(_cgo0, nil); return /*line :1606:51*/_Cfunc_WaitForSlotEvent(_cgo0, _cgo1, _cgo2); }()
	sl <- SlotEvent{uint(slotID)}
	close(sl) // TODO(miek): Sending and then closing ...?
}
