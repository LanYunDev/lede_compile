// Code generated by cmd/cgo; DO NOT EDIT.

//line /Volumes/2T/compile/lede/build_dir/target-x86_64_musl/runc-1.1.9/.go_work/build/src/github.com/opencontainers/runc/vendor/github.com/seccomp/libseccomp-golang/seccomp_internal.go:1:1
// Internal functions for libseccomp Go bindings
// No exported functions

package seccomp

import (
	"errors"
	"fmt"
	"syscall"
)

// Unexported C wrapping code - provides the C-Golang interface
// Get the seccomp header in scope
// Need stdlib.h for free() on cstrings

// To compile libseccomp-golang against a specific version of libseccomp:
// cd ../libseccomp && mkdir -p prefix
// ./configure --prefix=$PWD/prefix && make && make install
// cd ../libseccomp-golang
// PKG_CONFIG_PATH=$PWD/../libseccomp/prefix/lib/pkgconfig/ make
// LD_PRELOAD=$PWD/../libseccomp/prefix/lib/libseccomp.so.2.5.0 PKG_CONFIG_PATH=$PWD/../libseccomp/prefix/lib/pkgconfig/ make test

// #cgo pkg-config: libseccomp
/*
#include <errno.h>
#include <stdlib.h>
#include <seccomp.h>

#if (SCMP_VER_MAJOR < 2) || \
    (SCMP_VER_MAJOR == 2 && SCMP_VER_MINOR < 3) || \
    (SCMP_VER_MAJOR == 2 && SCMP_VER_MINOR == 3 && SCMP_VER_MICRO < 1)
#error This package requires libseccomp >= v2.3.1
#endif

#define ARCH_BAD ~0

const uint32_t C_ARCH_BAD = ARCH_BAD;

#ifndef SCMP_ARCH_PPC
#define SCMP_ARCH_PPC ARCH_BAD
#endif

#ifndef SCMP_ARCH_PPC64
#define SCMP_ARCH_PPC64 ARCH_BAD
#endif

#ifndef SCMP_ARCH_PPC64LE
#define SCMP_ARCH_PPC64LE ARCH_BAD
#endif

#ifndef SCMP_ARCH_S390
#define SCMP_ARCH_S390 ARCH_BAD
#endif

#ifndef SCMP_ARCH_S390X
#define SCMP_ARCH_S390X ARCH_BAD
#endif

#ifndef SCMP_ARCH_PARISC
#define SCMP_ARCH_PARISC ARCH_BAD
#endif

#ifndef SCMP_ARCH_PARISC64
#define SCMP_ARCH_PARISC64 ARCH_BAD
#endif

#ifndef SCMP_ARCH_RISCV64
#define SCMP_ARCH_RISCV64 ARCH_BAD
#endif

const uint32_t C_ARCH_NATIVE       = SCMP_ARCH_NATIVE;
const uint32_t C_ARCH_X86          = SCMP_ARCH_X86;
const uint32_t C_ARCH_X86_64       = SCMP_ARCH_X86_64;
const uint32_t C_ARCH_X32          = SCMP_ARCH_X32;
const uint32_t C_ARCH_ARM          = SCMP_ARCH_ARM;
const uint32_t C_ARCH_AARCH64      = SCMP_ARCH_AARCH64;
const uint32_t C_ARCH_MIPS         = SCMP_ARCH_MIPS;
const uint32_t C_ARCH_MIPS64       = SCMP_ARCH_MIPS64;
const uint32_t C_ARCH_MIPS64N32    = SCMP_ARCH_MIPS64N32;
const uint32_t C_ARCH_MIPSEL       = SCMP_ARCH_MIPSEL;
const uint32_t C_ARCH_MIPSEL64     = SCMP_ARCH_MIPSEL64;
const uint32_t C_ARCH_MIPSEL64N32  = SCMP_ARCH_MIPSEL64N32;
const uint32_t C_ARCH_PPC          = SCMP_ARCH_PPC;
const uint32_t C_ARCH_PPC64        = SCMP_ARCH_PPC64;
const uint32_t C_ARCH_PPC64LE      = SCMP_ARCH_PPC64LE;
const uint32_t C_ARCH_S390         = SCMP_ARCH_S390;
const uint32_t C_ARCH_S390X        = SCMP_ARCH_S390X;
const uint32_t C_ARCH_PARISC       = SCMP_ARCH_PARISC;
const uint32_t C_ARCH_PARISC64     = SCMP_ARCH_PARISC64;
const uint32_t C_ARCH_RISCV64      = SCMP_ARCH_RISCV64;

#ifndef SCMP_ACT_LOG
#define SCMP_ACT_LOG 0x7ffc0000U
#endif

#ifndef SCMP_ACT_KILL_PROCESS
#define SCMP_ACT_KILL_PROCESS 0x80000000U
#endif

#ifndef SCMP_ACT_KILL_THREAD
#define SCMP_ACT_KILL_THREAD	0x00000000U
#endif

#ifndef SCMP_ACT_NOTIFY
#define SCMP_ACT_NOTIFY 0x7fc00000U
#endif

const uint32_t C_ACT_KILL          = SCMP_ACT_KILL;
const uint32_t C_ACT_KILL_PROCESS  = SCMP_ACT_KILL_PROCESS;
const uint32_t C_ACT_KILL_THREAD   = SCMP_ACT_KILL_THREAD;
const uint32_t C_ACT_TRAP          = SCMP_ACT_TRAP;
const uint32_t C_ACT_ERRNO         = SCMP_ACT_ERRNO(0);
const uint32_t C_ACT_TRACE         = SCMP_ACT_TRACE(0);
const uint32_t C_ACT_LOG           = SCMP_ACT_LOG;
const uint32_t C_ACT_ALLOW         = SCMP_ACT_ALLOW;
const uint32_t C_ACT_NOTIFY        = SCMP_ACT_NOTIFY;

// The libseccomp SCMP_FLTATR_CTL_LOG member of the scmp_filter_attr enum was
// added in v2.4.0
#if SCMP_VER_MAJOR == 2 && SCMP_VER_MINOR < 4
#define SCMP_FLTATR_CTL_LOG _SCMP_FLTATR_MIN
#endif

// The following SCMP_FLTATR_*  were added in libseccomp v2.5.0.
#if SCMP_VER_MAJOR == 2 && SCMP_VER_MINOR < 5
#define SCMP_FLTATR_CTL_SSB      _SCMP_FLTATR_MIN
#define SCMP_FLTATR_CTL_OPTIMIZE _SCMP_FLTATR_MIN
#define SCMP_FLTATR_API_SYSRAWRC _SCMP_FLTATR_MIN
#endif

const uint32_t C_ATTRIBUTE_DEFAULT  = (uint32_t)SCMP_FLTATR_ACT_DEFAULT;
const uint32_t C_ATTRIBUTE_BADARCH  = (uint32_t)SCMP_FLTATR_ACT_BADARCH;
const uint32_t C_ATTRIBUTE_NNP      = (uint32_t)SCMP_FLTATR_CTL_NNP;
const uint32_t C_ATTRIBUTE_TSYNC    = (uint32_t)SCMP_FLTATR_CTL_TSYNC;
const uint32_t C_ATTRIBUTE_LOG      = (uint32_t)SCMP_FLTATR_CTL_LOG;
const uint32_t C_ATTRIBUTE_SSB      = (uint32_t)SCMP_FLTATR_CTL_SSB;
const uint32_t C_ATTRIBUTE_OPTIMIZE = (uint32_t)SCMP_FLTATR_CTL_OPTIMIZE;
const uint32_t C_ATTRIBUTE_SYSRAWRC = (uint32_t)SCMP_FLTATR_API_SYSRAWRC;

const int      C_CMP_NE            = (int)SCMP_CMP_NE;
const int      C_CMP_LT            = (int)SCMP_CMP_LT;
const int      C_CMP_LE            = (int)SCMP_CMP_LE;
const int      C_CMP_EQ            = (int)SCMP_CMP_EQ;
const int      C_CMP_GE            = (int)SCMP_CMP_GE;
const int      C_CMP_GT            = (int)SCMP_CMP_GT;
const int      C_CMP_MASKED_EQ     = (int)SCMP_CMP_MASKED_EQ;

const int      C_VERSION_MAJOR     = SCMP_VER_MAJOR;
const int      C_VERSION_MINOR     = SCMP_VER_MINOR;
const int      C_VERSION_MICRO     = SCMP_VER_MICRO;

#if SCMP_VER_MAJOR == 2 && SCMP_VER_MINOR >= 3
unsigned int get_major_version()
{
        return seccomp_version()->major;
}

unsigned int get_minor_version()
{
        return seccomp_version()->minor;
}

unsigned int get_micro_version()
{
        return seccomp_version()->micro;
}
#else
unsigned int get_major_version()
{
        return (unsigned int)C_VERSION_MAJOR;
}

unsigned int get_minor_version()
{
        return (unsigned int)C_VERSION_MINOR;
}

unsigned int get_micro_version()
{
        return (unsigned int)C_VERSION_MICRO;
}
#endif

// The libseccomp API level functions were added in v2.4.0
#if SCMP_VER_MAJOR == 2 && SCMP_VER_MINOR < 4
const unsigned int seccomp_api_get(void)
{
	// libseccomp-golang requires libseccomp v2.2.0, at a minimum, which
	// supported API level 2. However, the kernel may not support API level
	// 2 constructs which are the seccomp() system call and the TSYNC
	// filter flag. Return the "reserved" value of 0 here to indicate that
	// proper API level support is not available in libseccomp.
	return 0;
}

int seccomp_api_set(unsigned int level)
{
	return -EOPNOTSUPP;
}
#endif

typedef struct scmp_arg_cmp* scmp_cast_t;

void* make_arg_cmp_array(unsigned int length)
{
        return calloc(length, sizeof(struct scmp_arg_cmp));
}

// Wrapper to add an scmp_arg_cmp struct to an existing arg_cmp array
void add_struct_arg_cmp(
                        struct scmp_arg_cmp* arr,
                        unsigned int pos,
                        unsigned int arg,
                        int compare,
                        uint64_t a,
                        uint64_t b
                       )
{
        arr[pos].arg = arg;
        arr[pos].op = compare;
        arr[pos].datum_a = a;
        arr[pos].datum_b = b;

        return;
}

// The seccomp notify API functions were added in v2.5.0
#if SCMP_VER_MAJOR == 2 && SCMP_VER_MINOR < 5

struct seccomp_data {
	int nr;
	__u32 arch;
	__u64 instruction_pointer;
	__u64 args[6];
};

struct seccomp_notif {
	__u64 id;
	__u32 pid;
	__u32 flags;
	struct seccomp_data data;
};

struct seccomp_notif_resp {
	__u64 id;
	__s64 val;
	__s32 error;
	__u32 flags;
};

int seccomp_notify_alloc(struct seccomp_notif **req, struct seccomp_notif_resp **resp) {
	return -EOPNOTSUPP;
}
int seccomp_notify_fd(const scmp_filter_ctx ctx) {
	return -EOPNOTSUPP;
}
void seccomp_notify_free(struct seccomp_notif *req, struct seccomp_notif_resp *resp) {
}
int seccomp_notify_id_valid(int fd, uint64_t id) {
	return -EOPNOTSUPP;
}
int seccomp_notify_receive(int fd, struct seccomp_notif *req) {
	return -EOPNOTSUPP;
}
int seccomp_notify_respond(int fd, struct seccomp_notif_resp *resp) {
	return -EOPNOTSUPP;
}

#endif
*/
import _ "unsafe"

// Nonexported types
type scmpFilterAttr uint32

// Nonexported constants

const (
	filterAttrActDefault scmpFilterAttr = iota
	filterAttrActBadArch
	filterAttrNNP
	filterAttrTsync
	filterAttrLog
	filterAttrSSB
	filterAttrOptimize
	filterAttrRawRC
)

const (
	// An error return from certain libseccomp functions
	scmpError  /*line :291:12*/_Ctype_int /*line :291:17*/ = -1
	// Comparison boundaries to check for architecture validity
	archStart ScmpArch = ArchNative
	archEnd   ScmpArch = ArchRISCV64
	// Comparison boundaries to check for action validity
	actionStart ScmpAction = ActKillThread
	actionEnd   ScmpAction = ActKillProcess
	// Comparison boundaries to check for comparison operator validity
	compareOpStart ScmpCompareOp = CompareNotEqual
	compareOpEnd   ScmpCompareOp = CompareMaskedEqual
)

var (
	// errBadFilter is thrown on bad filter context.
	errBadFilter = errors.New("filter is invalid or uninitialized")
	errDefAction = errors.New("requested action matches default action of filter")
	// Constants representing library major, minor, and micro versions
	verMajor = uint(( /*line :308:18*/_Cfunc_get_major_version /*line :308:36*/)())
	verMinor = uint(( /*line :309:18*/_Cfunc_get_minor_version /*line :309:36*/)())
	verMicro = uint(( /*line :310:18*/_Cfunc_get_micro_version /*line :310:36*/)())
)

// Nonexported functions

// checkVersion returns an error if the libseccomp version being used
// is less than the one specified by major, minor, and micro arguments.
// Argument op is an arbitrary non-empty operation description, which
// is used as a part of the error message returned.
//
// Most users should use checkAPI instead.
func checkVersion(op string, major, minor, micro uint) error {
	if (verMajor > major) ||
		(verMajor == major && verMinor > minor) ||
		(verMajor == major && verMinor == minor && verMicro >= micro) {
		return nil
	}
	return &VersionError{
		op:    op,
		major: major,
		minor: minor,
		micro: micro,
	}
}

func ensureSupportedVersion() error {
	return checkVersion("seccomp", 2, 3, 1)
}

// Get the API level
func getAPI() (uint, error) {
	api := ( /*line :341:9*/_Cfunc_seccomp_api_get /*line :341:25*/)()
	if api == 0 {
		return 0, fmt.Errorf("API level operations are not supported")
	}

	return uint(api), nil
}

// Set the API level
func setAPI(api uint) error {
	if retCode := ( /*line :351:16*/_Cfunc_seccomp_api_set /*line :351:32*/)( /*line :351:34*/_Ctype_uint /*line :351:40*/(api)); retCode != 0 {
		if errRc(retCode) == syscall.EOPNOTSUPP {
			return fmt.Errorf("API level operations are not supported")
		}

		return fmt.Errorf("could not set API level: %v", retCode)
	}

	return nil
}

// Filter helpers

// Filter finalizer - ensure that kernel context for filters is freed
func filterFinalizer(f *ScmpFilter) {
	f.Release()
}

func errRc(rc  /*line :369:15*/_Ctype_int /*line :369:20*/) error {
	return syscall.Errno(-1 * rc)
}

// Get a raw filter attribute
func (f *ScmpFilter) getFilterAttr(attr scmpFilterAttr) ( /*line :374:58*/_Ctype_uint32_t /*line :374:68*/, error) {
	f.lock.Lock()
	defer f.lock.Unlock()

	if !f.valid {
		return 0x0, errBadFilter
	}

	var attribute  /*line :382:16*/_Ctype_uint32_t /*line :382:26*/

	retCode := func() _Ctype_int{ _cgo0 := /*line :384:32*/f.filterCtx; var _cgo1 uint32 = /*line :384:45*/attr.toNative(); var _cgo2 *_Ctype_uint32_t = /*line :384:62*/&attribute; _cgoCheckPointer(_cgo0, nil); return /*line :384:73*/_Cfunc_seccomp_attr_get(_cgo0, _cgo1, _cgo2); }()
	if retCode != 0 {
		return 0x0, errRc(retCode)
	}

	return attribute, nil
}

// Set a raw filter attribute
func (f *ScmpFilter) setFilterAttr(attr scmpFilterAttr, value  /*line :393:63*/_Ctype_uint32_t /*line :393:73*/) error {
	f.lock.Lock()
	defer f.lock.Unlock()

	if !f.valid {
		return errBadFilter
	}

	retCode := func() _Ctype_int{ _cgo0 := /*line :401:32*/f.filterCtx; var _cgo1 uint32 = /*line :401:45*/attr.toNative(); var _cgo2 _Ctype_uint32_t = /*line :401:62*/value; _cgoCheckPointer(_cgo0, nil); return /*line :401:68*/_Cfunc_seccomp_attr_set(_cgo0, _cgo1, _cgo2); }()
	if retCode != 0 {
		return errRc(retCode)
	}

	return nil
}

// DOES NOT LOCK OR CHECK VALIDITY
// Assumes caller has already done this
// Wrapper for seccomp_rule_add_... functions
func (f *ScmpFilter) addRuleWrapper(call ScmpSyscall, action ScmpAction, exact bool, length  /*line :412:93*/_Ctype_uint /*line :412:99*/, cond  /*line :412:106*/_Ctype_scmp_cast_t /*line :412:119*/) error {
	if length != 0 && cond == nil {
		return fmt.Errorf("null conditions list, but length is nonzero")
	}

	var retCode  /*line :417:14*/_Ctype_int /*line :417:19*/
	if exact {
		retCode = func() _Ctype_int{ _cgo0 := /*line :419:44*/f.filterCtx; var _cgo1 _Ctype_uint32_t = /*line :419:57*/action.toNative(); var _cgo2 _Ctype_int = _Ctype_int /*line :419:81*/(call); var _cgo3 _Ctype_uint = /*line :419:89*/length; var _cgo4 *_Ctype_struct_scmp_arg_cmp = /*line :419:97*/cond; _cgoCheckPointer(_cgo0, nil); return /*line :419:102*/_Cfunc_seccomp_rule_add_exact_array(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }()
	} else {
		retCode = func() _Ctype_int{ _cgo0 := /*line :421:38*/f.filterCtx; var _cgo1 _Ctype_uint32_t = /*line :421:51*/action.toNative(); var _cgo2 _Ctype_int = _Ctype_int /*line :421:75*/(call); var _cgo3 _Ctype_uint = /*line :421:83*/length; var _cgo4 *_Ctype_struct_scmp_arg_cmp = /*line :421:91*/cond; _cgoCheckPointer(_cgo0, nil); return /*line :421:96*/_Cfunc_seccomp_rule_add_array(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }()
	}

	if retCode != 0 {
		switch e := errRc(retCode); e {
		case syscall.EFAULT:
			return fmt.Errorf("unrecognized syscall %#x", int32(call))
		// libseccomp >= v2.5.0 returns EACCES, older versions return EPERM.
		// TODO: remove EPERM once libseccomp < v2.5.0 is not supported.
		case syscall.EPERM, syscall.EACCES:
			return errDefAction
		case syscall.EINVAL:
			return fmt.Errorf("two checks on same syscall argument")
		default:
			return e
		}
	}

	return nil
}

// Generic add function for filter rules
func (f *ScmpFilter) addRuleGeneric(call ScmpSyscall, action ScmpAction, exact bool, conds []ScmpCondition) error {
	f.lock.Lock()
	defer f.lock.Unlock()

	if !f.valid {
		return errBadFilter
	}

	if len(conds) == 0 {
		if err := f.addRuleWrapper(call, action, exact, 0, nil); err != nil {
			return err
		}
	} else {
		argsArr := ( /*line :456:14*/_Cfunc_make_arg_cmp_array /*line :456:33*/)( /*line :456:35*/_Ctype_uint /*line :456:41*/(len(conds)))
		if argsArr == nil {
			return fmt.Errorf("error allocating memory for conditions")
		}
		defer func() func() { _cgo0 := /*line :460:16*/argsArr; return func() { _cgoCheckPointer(_cgo0, nil); /*line :460:24*/_Cfunc_free(_cgo0); }}()()

		for i, cond := range conds {
			( /*line :463:4*/_Cfunc_add_struct_arg_cmp /*line :463:23*/)( /*line :463:25*/_Ctype_scmp_cast_t /*line :463:38*/(argsArr),  /*line :463:49*/_Ctype_uint /*line :463:55*/(i),
				 /*line :464:5*/_Ctype_uint /*line :464:11*/(cond.Argument), cond.Op.toNative(),
				 /*line :465:5*/_Ctype_uint64_t /*line :465:15*/(cond.Operand1),  /*line :465:32*/_Ctype_uint64_t /*line :465:42*/(cond.Operand2))
		}

		if err := f.addRuleWrapper(call, action, exact,  /*line :468:51*/_Ctype_uint /*line :468:57*/(len(conds)),  /*line :468:71*/_Ctype_scmp_cast_t /*line :468:84*/(argsArr)); err != nil {
			return err
		}
	}

	return nil
}

// Generic Helpers

// Helper - Sanitize Arch token input
func sanitizeArch(in ScmpArch) error {
	if in < archStart || in > archEnd {
		return fmt.Errorf("unrecognized architecture %#x", uint(in))
	}

	if in.toNative() == ( /*line :484:22*/*_Cvar_C_ARCH_BAD /*line :484:33*/) {
		return fmt.Errorf("architecture %v is not supported on this version of the library", in)
	}

	return nil
}

func sanitizeAction(in ScmpAction) error {
	inTmp := in & 0x0000FFFF
	if inTmp < actionStart || inTmp > actionEnd {
		return fmt.Errorf("unrecognized action %#x", uint(inTmp))
	}

	if inTmp != ActTrace && inTmp != ActErrno && (in&0xFFFF0000) != 0 {
		return fmt.Errorf("highest 16 bits must be zeroed except for Trace and Errno")
	}

	return nil
}

func sanitizeCompareOp(in ScmpCompareOp) error {
	if in < compareOpStart || in > compareOpEnd {
		return fmt.Errorf("unrecognized comparison operator %#x", uint(in))
	}

	return nil
}

func archFromNative(a  /*line :512:23*/_Ctype_uint32_t /*line :512:33*/) (ScmpArch, error) {
	switch a {
	case ( /*line :514:7*/*_Cvar_C_ARCH_X86 /*line :514:18*/):
		return ArchX86, nil
	case ( /*line :516:7*/*_Cvar_C_ARCH_X86_64 /*line :516:21*/):
		return ArchAMD64, nil
	case ( /*line :518:7*/*_Cvar_C_ARCH_X32 /*line :518:18*/):
		return ArchX32, nil
	case ( /*line :520:7*/*_Cvar_C_ARCH_ARM /*line :520:18*/):
		return ArchARM, nil
	case ( /*line :522:7*/*_Cvar_C_ARCH_NATIVE /*line :522:21*/):
		return ArchNative, nil
	case ( /*line :524:7*/*_Cvar_C_ARCH_AARCH64 /*line :524:22*/):
		return ArchARM64, nil
	case ( /*line :526:7*/*_Cvar_C_ARCH_MIPS /*line :526:19*/):
		return ArchMIPS, nil
	case ( /*line :528:7*/*_Cvar_C_ARCH_MIPS64 /*line :528:21*/):
		return ArchMIPS64, nil
	case ( /*line :530:7*/*_Cvar_C_ARCH_MIPS64N32 /*line :530:24*/):
		return ArchMIPS64N32, nil
	case ( /*line :532:7*/*_Cvar_C_ARCH_MIPSEL /*line :532:21*/):
		return ArchMIPSEL, nil
	case ( /*line :534:7*/*_Cvar_C_ARCH_MIPSEL64 /*line :534:23*/):
		return ArchMIPSEL64, nil
	case ( /*line :536:7*/*_Cvar_C_ARCH_MIPSEL64N32 /*line :536:26*/):
		return ArchMIPSEL64N32, nil
	case ( /*line :538:7*/*_Cvar_C_ARCH_PPC /*line :538:18*/):
		return ArchPPC, nil
	case ( /*line :540:7*/*_Cvar_C_ARCH_PPC64 /*line :540:20*/):
		return ArchPPC64, nil
	case ( /*line :542:7*/*_Cvar_C_ARCH_PPC64LE /*line :542:22*/):
		return ArchPPC64LE, nil
	case ( /*line :544:7*/*_Cvar_C_ARCH_S390 /*line :544:19*/):
		return ArchS390, nil
	case ( /*line :546:7*/*_Cvar_C_ARCH_S390X /*line :546:20*/):
		return ArchS390X, nil
	case ( /*line :548:7*/*_Cvar_C_ARCH_PARISC /*line :548:21*/):
		return ArchPARISC, nil
	case ( /*line :550:7*/*_Cvar_C_ARCH_PARISC64 /*line :550:23*/):
		return ArchPARISC64, nil
	case ( /*line :552:7*/*_Cvar_C_ARCH_RISCV64 /*line :552:22*/):
		return ArchRISCV64, nil
	default:
		return 0x0, fmt.Errorf("unrecognized architecture %#x", uint32(a))
	}
}

// Only use with sanitized arches, no error handling
func (a ScmpArch) toNative()  /*line :560:30*/_Ctype_uint32_t /*line :560:40*/ {
	switch a {
	case ArchX86:
		return ( /*line :563:10*/*_Cvar_C_ARCH_X86 /*line :563:21*/)
	case ArchAMD64:
		return ( /*line :565:10*/*_Cvar_C_ARCH_X86_64 /*line :565:24*/)
	case ArchX32:
		return ( /*line :567:10*/*_Cvar_C_ARCH_X32 /*line :567:21*/)
	case ArchARM:
		return ( /*line :569:10*/*_Cvar_C_ARCH_ARM /*line :569:21*/)
	case ArchARM64:
		return ( /*line :571:10*/*_Cvar_C_ARCH_AARCH64 /*line :571:25*/)
	case ArchMIPS:
		return ( /*line :573:10*/*_Cvar_C_ARCH_MIPS /*line :573:22*/)
	case ArchMIPS64:
		return ( /*line :575:10*/*_Cvar_C_ARCH_MIPS64 /*line :575:24*/)
	case ArchMIPS64N32:
		return ( /*line :577:10*/*_Cvar_C_ARCH_MIPS64N32 /*line :577:27*/)
	case ArchMIPSEL:
		return ( /*line :579:10*/*_Cvar_C_ARCH_MIPSEL /*line :579:24*/)
	case ArchMIPSEL64:
		return ( /*line :581:10*/*_Cvar_C_ARCH_MIPSEL64 /*line :581:26*/)
	case ArchMIPSEL64N32:
		return ( /*line :583:10*/*_Cvar_C_ARCH_MIPSEL64N32 /*line :583:29*/)
	case ArchPPC:
		return ( /*line :585:10*/*_Cvar_C_ARCH_PPC /*line :585:21*/)
	case ArchPPC64:
		return ( /*line :587:10*/*_Cvar_C_ARCH_PPC64 /*line :587:23*/)
	case ArchPPC64LE:
		return ( /*line :589:10*/*_Cvar_C_ARCH_PPC64LE /*line :589:25*/)
	case ArchS390:
		return ( /*line :591:10*/*_Cvar_C_ARCH_S390 /*line :591:22*/)
	case ArchS390X:
		return ( /*line :593:10*/*_Cvar_C_ARCH_S390X /*line :593:23*/)
	case ArchPARISC:
		return ( /*line :595:10*/*_Cvar_C_ARCH_PARISC /*line :595:24*/)
	case ArchPARISC64:
		return ( /*line :597:10*/*_Cvar_C_ARCH_PARISC64 /*line :597:26*/)
	case ArchRISCV64:
		return ( /*line :599:10*/*_Cvar_C_ARCH_RISCV64 /*line :599:25*/)
	case ArchNative:
		return ( /*line :601:10*/*_Cvar_C_ARCH_NATIVE /*line :601:24*/)
	default:
		return 0x0
	}
}

// Only use with sanitized ops, no error handling
func (a ScmpCompareOp) toNative()  /*line :608:35*/_Ctype_int /*line :608:40*/ {
	switch a {
	case CompareNotEqual:
		return ( /*line :611:10*/*_Cvar_C_CMP_NE /*line :611:19*/)
	case CompareLess:
		return ( /*line :613:10*/*_Cvar_C_CMP_LT /*line :613:19*/)
	case CompareLessOrEqual:
		return ( /*line :615:10*/*_Cvar_C_CMP_LE /*line :615:19*/)
	case CompareEqual:
		return ( /*line :617:10*/*_Cvar_C_CMP_EQ /*line :617:19*/)
	case CompareGreaterEqual:
		return ( /*line :619:10*/*_Cvar_C_CMP_GE /*line :619:19*/)
	case CompareGreater:
		return ( /*line :621:10*/*_Cvar_C_CMP_GT /*line :621:19*/)
	case CompareMaskedEqual:
		return ( /*line :623:10*/*_Cvar_C_CMP_MASKED_EQ /*line :623:26*/)
	default:
		return 0x0
	}
}

func actionFromNative(a  /*line :629:25*/_Ctype_uint32_t /*line :629:35*/) (ScmpAction, error) {
	aTmp := a & 0xFFFF
	switch a & 0xFFFF0000 {
	case ( /*line :632:7*/*_Cvar_C_ACT_KILL_PROCESS /*line :632:26*/):
		return ActKillProcess, nil
	case ( /*line :634:7*/*_Cvar_C_ACT_KILL_THREAD /*line :634:25*/):
		return ActKillThread, nil
	case ( /*line :636:7*/*_Cvar_C_ACT_TRAP /*line :636:18*/):
		return ActTrap, nil
	case ( /*line :638:7*/*_Cvar_C_ACT_ERRNO /*line :638:19*/):
		return ActErrno.SetReturnCode(int16(aTmp)), nil
	case ( /*line :640:7*/*_Cvar_C_ACT_TRACE /*line :640:19*/):
		return ActTrace.SetReturnCode(int16(aTmp)), nil
	case ( /*line :642:7*/*_Cvar_C_ACT_LOG /*line :642:17*/):
		return ActLog, nil
	case ( /*line :644:7*/*_Cvar_C_ACT_ALLOW /*line :644:19*/):
		return ActAllow, nil
	case ( /*line :646:7*/*_Cvar_C_ACT_NOTIFY /*line :646:20*/):
		return ActNotify, nil
	default:
		return 0x0, fmt.Errorf("unrecognized action %#x", uint32(a))
	}
}

// Only use with sanitized actions, no error handling
func (a ScmpAction) toNative()  /*line :654:32*/_Ctype_uint32_t /*line :654:42*/ {
	switch a & 0xFFFF {
	case ActKillProcess:
		return ( /*line :657:10*/*_Cvar_C_ACT_KILL_PROCESS /*line :657:29*/)
	case ActKillThread:
		return ( /*line :659:10*/*_Cvar_C_ACT_KILL_THREAD /*line :659:28*/)
	case ActTrap:
		return ( /*line :661:10*/*_Cvar_C_ACT_TRAP /*line :661:21*/)
	case ActErrno:
		return ( /*line :663:10*/*_Cvar_C_ACT_ERRNO /*line :663:22*/) | ( /*line :663:27*/_Ctype_uint32_t /*line :663:37*/(a) >> 16)
	case ActTrace:
		return ( /*line :665:10*/*_Cvar_C_ACT_TRACE /*line :665:22*/) | ( /*line :665:27*/_Ctype_uint32_t /*line :665:37*/(a) >> 16)
	case ActLog:
		return ( /*line :667:10*/*_Cvar_C_ACT_LOG /*line :667:20*/)
	case ActAllow:
		return ( /*line :669:10*/*_Cvar_C_ACT_ALLOW /*line :669:22*/)
	case ActNotify:
		return ( /*line :671:10*/*_Cvar_C_ACT_NOTIFY /*line :671:23*/)
	default:
		return 0x0
	}
}

// Internal only, assumes safe attribute
func (a scmpFilterAttr) toNative() uint32 {
	switch a {
	case filterAttrActDefault:
		return uint32(( /*line :681:17*/*_Cvar_C_ATTRIBUTE_DEFAULT /*line :681:37*/))
	case filterAttrActBadArch:
		return uint32(( /*line :683:17*/*_Cvar_C_ATTRIBUTE_BADARCH /*line :683:37*/))
	case filterAttrNNP:
		return uint32(( /*line :685:17*/*_Cvar_C_ATTRIBUTE_NNP /*line :685:33*/))
	case filterAttrTsync:
		return uint32(( /*line :687:17*/*_Cvar_C_ATTRIBUTE_TSYNC /*line :687:35*/))
	case filterAttrLog:
		return uint32(( /*line :689:17*/*_Cvar_C_ATTRIBUTE_LOG /*line :689:33*/))
	case filterAttrSSB:
		return uint32(( /*line :691:17*/*_Cvar_C_ATTRIBUTE_SSB /*line :691:33*/))
	case filterAttrOptimize:
		return uint32(( /*line :693:17*/*_Cvar_C_ATTRIBUTE_OPTIMIZE /*line :693:38*/))
	case filterAttrRawRC:
		return uint32(( /*line :695:17*/*_Cvar_C_ATTRIBUTE_SYSRAWRC /*line :695:38*/))
	default:
		return 0x0
	}
}

func syscallFromNative(a  /*line :701:26*/_Ctype_int /*line :701:31*/) ScmpSyscall {
	return ScmpSyscall(a)
}

func notifReqFromNative(req * /*line :705:30*/_Ctype_struct_seccomp_notif /*line :705:52*/) (*ScmpNotifReq, error) {
	scmpArgs := make([]uint64, 6)
	for i := 0; i < len(scmpArgs); i++ {
		scmpArgs[i] = uint64(req.data.args[i])
	}

	arch, err := archFromNative(req.data.arch)
	if err != nil {
		return nil, err
	}

	scmpData := ScmpNotifData{
		Syscall:      syscallFromNative(req.data.nr),
		Arch:         arch,
		InstrPointer: uint64(req.data.instruction_pointer),
		Args:         scmpArgs,
	}

	scmpReq := &ScmpNotifReq{
		ID:    uint64(req.id),
		Pid:   uint32(req.pid),
		Flags: uint32(req.flags),
		Data:  scmpData,
	}

	return scmpReq, nil
}

func (scmpResp *ScmpNotifResp) toNative(resp * /*line :733:47*/_Ctype_struct_seccomp_notif_resp /*line :733:74*/) {
	resp.id =  /*line :734:12*/_Ctype___u64 /*line :734:19*/(scmpResp.ID)
	resp.val =  /*line :735:13*/_Ctype___s64 /*line :735:20*/(scmpResp.Val)
	resp.error = ( /*line :736:16*/_Ctype___s32 /*line :736:23*/(scmpResp.Error) * -1) // kernel requires a negated value
	resp.flags =  /*line :737:15*/_Ctype___u32 /*line :737:22*/(scmpResp.Flags)
}

// checkAPI checks that both the API level and the seccomp version is equal to
// or greater than the specified minLevel and major, minor, micro,
// respectively, and returns an error otherwise. Argument op is an arbitrary
// non-empty operation description, used as a part of the error message
// returned.
func checkAPI(op string, minLevel uint, major, minor, micro uint) error {
	// Ignore error from getAPI, as it returns level == 0 in case of error.
	level, _ := getAPI()
	if level >= minLevel {
		return checkVersion(op, major, minor, micro)
	}
	return &VersionError{
		op:     op,
		curAPI: level,
		minAPI: minLevel,
		major:  major,
		minor:  minor,
		micro:  micro,
	}
}

// Userspace Notification API
// Calls to C.seccomp_notify* hidden from seccomp.go

func notifSupported() error {
	return checkAPI("seccomp notification", 6, 2, 5, 0)
}

func (f *ScmpFilter) getNotifFd() (ScmpFd, error) {
	f.lock.Lock()
	defer f.lock.Unlock()

	if !f.valid {
		return -1, errBadFilter
	}
	if err := notifSupported(); err != nil {
		return -1, err
	}

	fd := func() _Ctype_int{ _cgo0 := /*line :779:28*/f.filterCtx; _cgoCheckPointer(_cgo0, nil); return /*line :779:40*/_Cfunc_seccomp_notify_fd(_cgo0); }()

	return ScmpFd(fd), nil
}

func notifReceive(fd ScmpFd) (*ScmpNotifReq, error) {
	var req * /*line :785:11*/_Ctype_struct_seccomp_notif /*line :785:33*/
	var resp * /*line :786:12*/_Ctype_struct_seccomp_notif_resp /*line :786:39*/

	if err := notifSupported(); err != nil {
		return nil, err
	}

	// we only use the request here; the response is unused
	if retCode := func() _Ctype_int{ _cgoBase0 := /*line :793:39*/&req; _cgo0 := _cgoBase0; _cgoBase1 := /*line :793:45*/&resp; _cgo1 := _cgoBase1; _cgoCheckPointer(_cgoBase0, 0 == 0); _cgoCheckPointer(_cgoBase1, 0 == 0); return /*line :793:51*/_Cfunc_seccomp_notify_alloc(_cgo0, _cgo1); }(); retCode != 0 {
		return nil, errRc(retCode)
	}

	defer func() {
		( /*line :798:3*/_Cfunc_seccomp_notify_free /*line :798:23*/)(req, resp)
	}()

	for {
		retCode, errno := ( /*line :802:21*/_C2func_seccomp_notify_receive /*line :802:44*/)( /*line :802:46*/_Ctype_int /*line :802:51*/(fd), req)
		if retCode == 0 {
			break
		}

		if errno == syscall.EINTR {
			continue
		}

		if errno == syscall.ENOENT {
			return nil, errno
		}

		return nil, errRc(retCode)
	}

	return notifReqFromNative(req)
}

func notifRespond(fd ScmpFd, scmpResp *ScmpNotifResp) error {
	var req * /*line :822:11*/_Ctype_struct_seccomp_notif /*line :822:33*/
	var resp * /*line :823:12*/_Ctype_struct_seccomp_notif_resp /*line :823:39*/

	if err := notifSupported(); err != nil {
		return err
	}

	// we only use the response here; the request is discarded
	if retCode := func() _Ctype_int{ _cgoBase0 := /*line :830:39*/&req; _cgo0 := _cgoBase0; _cgoBase1 := /*line :830:45*/&resp; _cgo1 := _cgoBase1; _cgoCheckPointer(_cgoBase0, 0 == 0); _cgoCheckPointer(_cgoBase1, 0 == 0); return /*line :830:51*/_Cfunc_seccomp_notify_alloc(_cgo0, _cgo1); }(); retCode != 0 {
		return errRc(retCode)
	}

	defer func() {
		( /*line :835:3*/_Cfunc_seccomp_notify_free /*line :835:23*/)(req, resp)
	}()

	scmpResp.toNative(resp)

	for {
		retCode, errno := ( /*line :841:21*/_C2func_seccomp_notify_respond /*line :841:44*/)( /*line :841:46*/_Ctype_int /*line :841:51*/(fd), resp)
		if retCode == 0 {
			break
		}

		if errno == syscall.EINTR {
			continue
		}

		if errno == syscall.ENOENT {
			return errno
		}

		return errRc(retCode)
	}

	return nil
}

func notifIDValid(fd ScmpFd, id uint64) error {
	if err := notifSupported(); err != nil {
		return err
	}

	for {
		retCode, errno := ( /*line :866:21*/_C2func_seccomp_notify_id_valid /*line :866:45*/)( /*line :866:47*/_Ctype_int /*line :866:52*/(fd),  /*line :866:58*/_Ctype_uint64_t /*line :866:68*/(id))
		if retCode == 0 {
			break
		}

		if errno == syscall.EINTR {
			continue
		}

		if errno == syscall.ENOENT {
			return errno
		}

		return errRc(retCode)
	}

	return nil
}
