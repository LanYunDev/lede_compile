// Code generated by cmd/cgo; DO NOT EDIT.

//line /Volumes/2T/compile/lede/build_dir/target-x86_64_musl/rclone-1.61.1/librclone/librclone.go:1:1
// Package librclone exports shims for C library use
//
// This directory contains code to build rclone as a C library and the
// shims for accessing rclone from C.
//
// The shims are a thin wrapper over the rclone RPC.
//
// Build a shared library like this:
//
//	go build --buildmode=c-shared -o librclone.so github.com/rclone/rclone/librclone
//
// Build a static library like this:
//
//	go build --buildmode=c-archive -o librclone.a github.com/rclone/rclone/librclone
//
// Both the above commands will also generate `librclone.h` which should
// be `#include`d in `C` programs wishing to use the library.
//
// The library will depend on `libdl` and `libpthread`.
package main

/*
#include <stdlib.h>

struct RcloneRPCResult {
	char*	Output;
	int	Status;
};
*/
import _ "unsafe"

import (
	"unsafe"

	"github.com/rclone/rclone/librclone/librclone"

	_ "github.com/rclone/rclone/backend/all"   // import all backends
	_ "github.com/rclone/rclone/cmd/cmount"    // import cmount
	_ "github.com/rclone/rclone/cmd/mount"     // import mount
	_ "github.com/rclone/rclone/cmd/mount2"    // import mount2
	_ "github.com/rclone/rclone/fs/operations" // import operations/* rc commands
	_ "github.com/rclone/rclone/fs/sync"       // import sync/*
	// _ "github.com/rclone/rclone/lib/plugin"    // import plugins
)

// RcloneInitialize initializes rclone as a library
//
//export RcloneInitialize
func RcloneInitialize() {
	librclone.Initialize()
}

// RcloneFinalize finalizes the library
//
//export RcloneFinalize
func RcloneFinalize() {
	librclone.Finalize()
}

// RcloneRPCResult is returned from RcloneRPC
//
//	Output will be returned as a serialized JSON object
//	Status is a HTTP status return (200=OK anything else fail)
type RcloneRPCResult struct { //nolint:deadcode
	Output * /*line :65:10*/_Ctype_char /*line :65:16*/
	Status  /*line :66:9*/_Ctype_int /*line :66:14*/
}

// RcloneRPC does a single RPC call. The inputs are (method, input)
// and the output is (output, status). This is an exported interface
// to the rclone API as described in https://rclone.org/rc/
//
//	method is a string, eg "operations/list"
//	input should be a string with a serialized JSON object
//	result.Output will be returned as a string with a serialized JSON object
//	result.Status is a HTTP status return (200=OK anything else fail)
//
// All strings are UTF-8 encoded, on all platforms.
//
// Caller is responsible for freeing the memory for result.Output
// (see RcloneFreeString), result itself is passed on the stack.
//
//export RcloneRPC
func RcloneRPC(method * /*line :84:24*/_Ctype_char /*line :84:30*/, input * /*line :84:39*/_Ctype_char /*line :84:45*/) (result  /*line :84:55*/_Ctype_struct_RcloneRPCResult /*line :84:79*/) { //nolint:golint
	output, status := librclone.RPC(( /*line :85:34*/_Cfunc_GoString /*line :85:43*/)(method), ( /*line :85:54*/_Cfunc_GoString /*line :85:63*/)(input))
	result.Output = ( /*line :86:18*/_Cfunc_CString /*line :86:26*/)(output)
	result.Status =  /*line :87:18*/_Ctype_int /*line :87:23*/(status)
	return result
}

// RcloneFreeString may be used to free the string returned by RcloneRPC
//
// If the caller has access to the C standard library, the free function can
// normally be called directly instead. In some cases the caller uses a
// runtime library which is not compatible, and then this function can be
// used to release the memory with the same library that allocated it.
//
//export RcloneFreeString
func RcloneFreeString(str * /*line :99:28*/_Ctype_char /*line :99:34*/) {
	func() { _cgo0 := /*line :100:9*/unsafe.Pointer(str); _cgoCheckPointer(_cgo0, nil); /*line :100:29*/_Cfunc_free(_cgo0); }()
}

// do nothing here - necessary for building into a C library
func main() {}
